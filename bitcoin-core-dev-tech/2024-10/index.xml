<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bitcoin Core Dev Tech 2024 (Oct) on ₿itcoin Transcripts</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/</link><description>Recent content in Bitcoin Core Dev Tech 2024 (Oct) on ₿itcoin Transcripts</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 17 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/index.xml" rel="self" type="application/rss+xml"/><item><title>Covenants</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/covenants/</link><pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/covenants/</guid><description>1) What are we solving? scaling? 10x, 20x, 100x? new use cases? giving users sovereignty? MEV concerns? 2) Different groups (some overlap with above): &amp;ldquo;ticking clock&amp;rdquo; for self-custody slow and steady buildoors ossification now 3) Various approaches: a. One weird trick (CAT? CTV?)
b. App-specific (APO), &amp;ldquo;LNHANCE&amp;rdquo;
c. minimal batched toolset: TXHASH(CTV), CSFS, CAT, TAPTWEAK, ???, Could keep going on this: OP_MUL, other general tools
d. overhaul: Great Script Restoration (GSR) - (overhaul of script engine sigops-&amp;gt; varops)</description></item><item><title>Erlay</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/erlay/</link><pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/erlay/</guid><description>Idea from 2018, code since 2021 code-wise, only 20% of the high-level code is merged (not counting low-level minisketch code): The basic structure, plus code for peer signaling has been merged -&amp;gt; good time to join, Review is needed
Open questions mostly concern policies (decisions of nodes) - there are various details still under discussion, such as picking parameters, details in logic etc. BIP330 only defines protocol, but not the policy decisions</description></item><item><title>Flamegraphs</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/flamegraphs/</link><pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/flamegraphs/</guid><description>Demo&amp;rsquo;ed a new (~4 years old) script available in the Linux kernel&amp;rsquo;s perf tool for easily recording and generating flamegraphs in a single shot. (perf script flamegraph) The main interest of the demo was to show how easy and low overhead flamegraph recording is using the perf tool now, and to show some of the small configuration issues / gotchas in setting up with bitcoin core, namely compiling with -fno-omit-frame-pointer, and getting an html template dependency on Debian.</description></item><item><title>Multi_index Replacement</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/multi_index-replacement/</link><pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/multi_index-replacement/</guid><description>Mostly looking for concept ACKs/NACKs
Q: Why would anyone be opposed? A: Boost pretty much just works and we&amp;rsquo;d be replacing it with something custom and untested. Follow-up Q: But is there any reason to believe that our testing/fuzzing would be insufficient? A: Nope. Q: What is the status? A: A full drop-in replacement for the subset of boost has been written. It currently passes all tests and meets or beats our existing benchmarks.</description></item><item><title>Stratum V2</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/stratumv2/</link><pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/stratumv2/</guid><description>Overall question: Do we include it in Bitcoin Core or do we have it maintained separately as an IPC mining interface (multi-process approach)?
Pros of including in Core:
Would be exposed to a higher level of review and so the code itself would likely end up being of higher quality Would possibly be easier for new miners to enter the space if it’s simply included in the bitcoin core binary (vs two binaries) Cons:</description></item><item><title>RPC Discussion</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/rpc-discussion/</link><pubDate>Wed, 16 Oct 2024 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/rpc-discussion/</guid><description>Spec Issue: https://github.com/bitcoin/bitcoin/issues/29912
Core Lightning is using JSON-schema to generate a lot of stuff, should see if we can replicate that for our RPC interface. Enables generating Rust client bindings, Golang, JavaScript?&amp;hellip;
Having generated client code could help decrease maintained code in bitcoin CLI, like special handling of non-string args.
Exact currency units should be defined in the schema to avoid past confusion. Still some concerns over more complex units like BTC/KvB and sats/vB.</description></item><item><title>Block Stalling</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/block-stalling/</link><pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/block-stalling/</guid><description>https://github.com/bitcoin/bitcoin/pull/29664
There are 2 mechanisms to deal with stalling.
If we&amp;rsquo;re close to the tip - we download from additional peers via compact blocks. If we&amp;rsquo;re far behind the tip (1024 blocks or more) - we kick stalling peers. Between these regimes there&amp;rsquo;s no existing mechanism to deal with block stalling - except fixed 10 minute timeout.
We could extend mechanism 1 or 2 to this inermediate zone(not at tip + not deep inside blockchain).</description></item><item><title>Kernel</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/kernel/</link><pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/kernel/</guid><description>STATUS Two recent Kernel workshops on what an API would look like and to polish the API. Also consideration on how Kernel would interplay with multiprocess
External C header API PR opened #30595 Script validation Logging Block validation Reading block and undo data Initial scope to these few things. Yet powerful.
Tx processing, header processing, coinsdb on a separate branch. Not a big addition to add that in eventually
Example applications using it coded up block-linearizer bitcoin-chainstate replacement Working on polishing internals More ergonomic for future versions of the API RUST-BITCOINKERNEL Unit and fuzz tests helped expose a crash bug also present in the old libbitcoinconsensus interface Separate fuzzing interface convenient and easier to iterate on</description></item><item><title>LevelDB Benchmarking &amp; IBD performance</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/leveldb/</link><pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/leveldb/</guid><description>Interested in benchmarking because interested in replacing leveldb to allow reading from other processes, need reliable way to benchmark changes like this. So far been benchmarking using hyperfine, investigating IBD Problem was that IBD takes a long time, wanted faster iteration cycles To support this, using patch adding flag that pauses background download when assumeutxo snapshots loaded Found MDBX outperformed leveldb processing new blocks after snapshot, and outperformed it overall, but leveldb was faster than MDBX processing old blocks Want to figure out why behavior changed between old / new blocks, maybe transactions longer lived previously MDBX is more efficient for reads, less efficient for writes compared to leveldb Also experimented with newer upstream leveldb version and with rocksdb (facebook fork of leveldb) Rocksdb has many more parameters which could be drawback but has option groups to simplify Is database bottleneck for IDB?</description></item><item><title>Mining Interface</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/mining-interface/</link><pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/mining-interface/</guid><description>Main use case is a Stratum v2 client connecting over IPC.
Most of the proposed interface is already merged: https://github.com/bitcoin/bitcoin/blob/master/src/interfaces/mining.h
Open PR to add waitFeesChanged: https://github.com/bitcoin/bitcoin/pull/31003
We walked through the interface.
Discussion about memory management: any time getBlock is called the node creates a new block template, which contains many transaction references. If the mempool drops these transactions they’ll stay in memory. How to limit the additional memory footprint?
Add interface method to request current memory usage If memory usage exceeds some (configurable) value, refuse to make more templates.</description></item><item><title>Multiprocess Binaries</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/multiprocess-binaries/</link><pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/multiprocess-binaries/</guid><description>Should we make separate multiprocess binaries, and where should they be placed?
The mining binary ideally gets released in the v29 release so SV2 users don&amp;rsquo;t need to compile their own binaries.
Builds Do we just turn multiprocess on for depends builds? E.g. that wouldn&amp;rsquo;t test multiprocess in all current CI jobs. Whereas if we enable multiprocess by default, that But besides the build flag, at least some functional tests also need changes to test the multiprocess binaries.</description></item><item><title>Payjoin</title><link>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/payjoin/</link><pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/bitcoin-core-dev-tech/2024-10/payjoin/</guid><description>Should Payjoin be introduced into Bitcoin Core wallet? Not a strong yes, but no direct objections.
Effect on Existing Wallet Users Would require user interaction, so if the user doesn&amp;rsquo;t initiate Payjoin, the corresponding code path wouldn’t be invoked.
HTTP Does Payjoin require HTTPS to be re-introduced? No, Payjoin uses Oblivious HTTP. Uses HTTP with an encrypted payload. Could use existing crypto modules in Bitcoin. HTTP in Bitcoin Core is a larger topic, so the implementation of HTTP for Payjoin should align with the larger usage of HTTP.</description></item></channel></rss>