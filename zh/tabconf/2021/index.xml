<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TABConf 2021 on ₿itcoin 记录稿</title><link>https://btctranscripts.com/zh/tabconf/2021/</link><description>Recent content in TABConf 2021 on ₿itcoin 记录稿</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 06 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://btctranscripts.com/zh/tabconf/2021/index.xml" rel="self" type="application/rss+xml"/><item><title>Miniscript</title><link>https://btctranscripts.com/zh/tabconf/2021/2021-11-06-andrew-poelstra-miniscript/</link><pubDate>Sat, 06 Nov 2021 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2021/2021-11-06-andrew-poelstra-miniscript/</guid><description>主题：Miniscript：资金保管，可计算，可组合
场合：TABConf (The Atlanta Bitcoin Conference)
幻灯片：https://download.wpsoftware.net/bitcoin/wizardry/2021-11-tabconf/slides.pdf
引言 我准备讲讲 Miniscript。有些东西我之前就讲过，只不过讲述的方式更偏技术，侧重于讲解 Bitcoin Script 语言的困境、Miniscript 是什么、如何使用 Miniscript，等等。今天我准备从真正尝试使用比特币的人的角度谈谈 Miniscript，看看它是怎么解决这个行业中的一些我认为极为关键的问题的 —— 资金保管（custody）、密钥跟踪，等等。
在开始之前，我要先介绍一下本次演讲的结构。我准备花几页幻灯片稍微讲一讲比特币的脚本（bitcoin script）。比特币脚本是比特币内置的一个系统，用来定义资金的花费条件。一般来说，在普通的比特币钱包中，它使用的脚本的意思是 “为了移动这笔资金，交易需要提供某个公钥的签名”。这种脚本只是包在你的公钥上的薄薄的一层皮。但你还可以用脚本做出更有意思的东西。你可以指定，“这里有 3 个公钥，需要任意 2 个公钥的签名（才能花费这笔资金）”，比如说实现基于 2-of-3 多签名的保管方案。你还可以检查某个公钥在启用之前是否经过了特定的一段时间。你可以检查某个哈希值的原像是否被揭晓（这就是闪电网络的 HTLC 的工作原理）。所有这些巧妙的技术特性都可以在比特币脚本中实现。
但在现实中，有一些问题导致这些特性极难使用。结果就是当前的绝大部分比特币钱包完全不使用有趣的脚本。它们不单这么做，还做得彼此之间无法互通。
我想证明的正是，在 Bitcoin Script 以外，我们还有别的办法可以编写比特币的脚本；你可以使用这个被称为 “Miniscript” 的方法，获得一个易于分析的脚本编写框架。
资金保管是我持续关注的问题。你如何保管你的币？“可计算”，意味着有了 Miniscript，你可以分析你的脚本在做什么。你可以分辨出它的开销，因此可以作出准确的手续费估计。你可以确定你的脚本的语义特性。你还可以问这样的问题：“给定一些任意复杂的脚本，有人能不使用我的签名而使用这些脚本拿走我的资金吗？”对任何复杂的脚本我们都应该追问这个问题。在 Miniscript 之前，答案基本上就是：“我不知道。别用它。老实使用你知道的东西、老实沿用模板，老实使用大家分析过的东西。” 但有了 Miniscript ，你就可以编写任意复杂的脚本，同时依然能回答这个问题。第三个关键词是 “可组合”。这个很有趣，它本身是一个技术词汇，但它的前提非常直接。如果你有一个高级的花费方案（spending policy），但你想把其中的某一部分替换成一些复杂的东西，如果你只有 Bitcoin Script，你是无法轻易且可验证地做到的。但有了 Miniscript 你就可以做到。
一个例子是，你是一家公司的董事，这家公司持有大量比特币。你同意参与某种多签名方案，5 名董事中需要 4 位的签名才能移动资金。你是成员之一。现在其他人要求你提供一个公钥。但你不想给它们 一把 公钥，因为你可能会弄丢对应的私钥。你不把自己的比特币放在只有一个公钥控制的输出中也是同样的理由。你想要一些冗余，一些弹性。所以，理想情况下，你应该能表示 “在这个 4-of-5 方案中，我的部分将是一个 2-of-3 方案。我把这三个公钥放在了不同的地点，按不同的方式保护了起来。” 使用 Bitcoin Script 你是做不到的。如果某人向你请求一个公钥，而你回复以这样复杂的公钥组合和规则，收到信息的人以及参与同一个脚本的其他人都需要艰难地验证你这部分没有错。基本上，你做的事情就是提供一段脚本（一段计算机代码）、要求把这段代码插入到另一段计算机程序中，而这段程序的模式并不符合人们思考花费方案的方式。
Bitcoin Script 的问题 我这里有几张幻灯片列举了 Script 的问题。有一些是非常技术性的，只有钱包开发者才会在意。有一些则是每个人等应该关注的，尤其是前两个。</description></item><item><title>Covenants</title><link>https://btctranscripts.com/zh/tabconf/2021/2021-11-05-jeremy-rubin-andrew-poelstra-covenants/</link><pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2021/2021-11-05-jeremy-rubin-andrew-poelstra-covenants/</guid><description>主题：Covenants
场合：TABConf (The Atlanta Bitcoin Conference)
视频：互联网上无视频放出。
根据 “苏格拉底村” 规则，（除了演讲者之外）所有与会者都使用了假名；音频也不会公开，以保护提问者的匿名。
限制条款的概念 Shaun Apps（SA）：我先做个开场吧。Andrew 和 Jeremy 都会来。然后我们就以问答的形式开展，最后再回答观众的提问。这就是本场演讲的形式。
SA：言归正传，限制条款（covenant）。这个术语有宗教和法律方面的历史语境。大多数人理解的可能是物权法范畴内的概念，比如使用限制条款来约束土地的用途。但是，你们有多少人知道它在比特币领域内的意思？好的，看来很多人都听过。所以，基本上，限制条款给予了比特币脚本内省的能力，例如你可以通过预先定义的约束来限制一个输出的花费方式。我不太清楚限制条款的概念可以追溯到多久远以前。但是这一篇影响力很大的 BitcoinTalk 论坛帖子，作者是 Greg Maxwell，就介绍了限制条款的概念，并提出了一些假想的案例。举个例子，一种 Smashcoin 限制条款，在花费由此种条款锁定的资金时，必须提供攻击另一种密码货币的证据；甚至是一种 adultcoin 限制条款，必须提供某人的生日才能花费，它会限制接收者的年龄必须大于 18 岁。当然，这些都只是假设的、博君一笑的例子，这篇帖子也只是一个玩笑。但是，今天我们能够看到，限制条款有一些非常激动人心的用途。有请 Andrew Poelstra 和 Jeremy Rubin。Andrew 准备从 CHECKSIGFROMSTACK（也叫 “CSFS”）的视角出发，理解限制条款。Jeremy 的演讲则讨论 CHECKTEMPLATEVERIFY（也叫 “CTV”）。其实，有不止一种办法可以在比特币中实现限制条款。不同的想法、不同的提议，都有自己的取舍也应用场景。所以，我们来好好探究一番。Andrew，你想先来吗？
Andrew Poelstra（AP）：当然。如 Shaun 所说，某种程度上我代表着限制条款的 CHECKSIGFROMSTACK 流派。这种流派似乎代表着一种更普遍的视角。所以，为了帮助大家建立限制条款的概念 —— 我认为，这个概念确实肇始于那个 BitcoinTalk 帖子 …… 我不知道有什么讨论比这个更早 ……
Jeremy Rubin（JR）：那也是我所知最早的。
递归和非递归的限制条款 AP：有两种类型的限制条款，我把它们叫做 “递归型限制条款” 和 “非递归型限制条款”。我想这两个术语可能也源自那篇文章。“限制条款” 是且只是一种限制资金可以花到哪里去的办法。使用比特币脚本，你可以决定在什么条件下一笔资金可以移动，然而，一旦条件满足，资金就可以去任何地方。而限制条款则更进一步，允许你限制它的去向，实现上面说的种种傻事。
非递归的限制条款和递归的限制条款有一个区别。在非递归的限制条款中，你可以限制一笔资金的去向。你可以把它引到另一个限制条款中，从而进一步约束其去向，等等。但是，你必须规划出这笔资金的全部未来，你可以让它经历很多个限制条款，但你必须在一开始就把所有的限制条款写出来。递归型限制条款则不同，你可以让资金回到一个本质上与其来源相同的限制条款中；这就创造了一种有限的状态机，资金可以在不同的状态中移动。要么资金可以只待在一个地方，只是改变一些常数；要么它们可以移动到不同的状态，甚至它们可以返回原来的状态。凭借它，你可以创建一种让资金无法逃离的限制条款。甚至我的用词，“无法逃离”，也反映出其内在的危险性，同时也反映了许多年来人们对启用递归限制条款的恐惧。
不同的限制条款提议 AP：这些年出现了许多的限制条款提议。其中一个是 Jeremy Rubin 的 OP_CTV，曾用名 “OP_SECURETHEBAG”。在它的整个生命中，它有过多个名称，也经历了几次迭代。OP_CTV 被有意设计成规避递归型限制条款，以避免所有这些看似是玩笑、某个层面上又不是玩笑的东西。不过，另一种非常著名的限制条款提议，是非常通用的，它基于两种新的操作码，CHECKSIGFROMSTACK 和 CAT。 还有一种更为高效的变种，它增设的操作码可以直接检查正在花费这笔资金的交易。也就是说你可以直接把花费资金的交易本身拉取到堆栈中，然后执行你的脚本、直接地约束它们。一定程度上，你是在直接检查花费资金的交易、为之施加任意的约束。尤其是，如果你限制了交易的输出，那你就实现了一种递归型限制条款，可以永久困住这笔资金。这两种方法之间存在取舍。如果你尝试做一些事情来避免递归型限制条款 ……</description></item></channel></rss>