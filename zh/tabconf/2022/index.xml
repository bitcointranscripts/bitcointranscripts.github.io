<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TABConf 2022 on ₿itcoin 记录稿</title><link>https://btctranscripts.com/zh/tabconf/2022/</link><description>Recent content in TABConf 2022 on ₿itcoin 记录稿</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 15 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://btctranscripts.com/zh/tabconf/2022/index.xml" rel="self" type="application/rss+xml"/><item><title>Braidpool</title><link>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-braidpool/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-braidpool/</guid><description>引言 今天我准备讲讲 Braidpool，这是一种去中心化的矿池协议。希望在座有人参加了今天早些时候的矿业圆桌，尤其是关于 p2pool 的。Braidpool 是 p2pool 的后继者。很久以前我做过一次关于有向无环图（DAG）区块链的演讲。
Braidpool Braidpool 是一个去中心化的矿池提议，它使用了一个合并挖矿的 DAG 以及类中本聪的共识协议来跟踪矿工的贡献（shares）。这是我能够想象的最直接的在 DAG 上应用中本聪共识的想法。它保证了所有的矿工都会通过这个合并挖矿的另类区块链得到支付。它使用一套矿工的参与机制和一个很大的多签名机制（使用 FROST、ROAST 或者 MuSig2）来签名 coinbase 支付（或者说结算交易）。我们使用大规模多签名的能力，让这一切成为了可能。它会通过一个 “UTXO 集” 来跟踪矿池对矿工的欠款，这个 UTXO 实际上是一组交易（未花费的哈希化支付输出，Unspent Hasher Payment Output）。它瞄准的是参与者之间的恒定方差。每个矿工都有不同的挖矿难度，但我们希望为所有的矿工实现相同的出块率。它还允许发送矿工的贡献额，因此可以产生哈希率的期货和期权。可以是一个表示兆哈希（terahash）的币，你可以把它发送给别人，然后立即根据你提供的挖矿份额得到支付，或者基于此推出期货和期权。
大纲 有四个大类需要讨论。很久以前我曾经在推特上发表过我对这些分类的 “一般考量”。你必须定义什么是 shares（或者说 “准区块（weak blocks）”），然后你需要一种共识算法，我选择 Braid 是因为它的精神跟比特币最接近。然后你需要一种办法，将 coinbase （挖矿收益）合计到一笔滚动更新的交易中，表示（对矿工的）支付额的更新；最后，你需要签名，将收益支付给所有矿工。
Shares 在一个去中心化的矿池中，一个 “share” 就是一个准区块：一个完整的比特币区块，但不必然能满足比特币网络的出块难度。你从一个比特币区块开始，但这个区块并不必然能满足比特币网络的出块难度。这就是我要跟矿池中的其他所有人说明的事：我正在挖掘这个区块，要是我挖出了一个满足难度要求的区块，你们就会得到支付；我在遵守规则，要是我出了一个区块，你们会得到收益，反过来也如此，因为我们同在一个矿池中。支付交易按过往应该支付的数额滚动累加而成。还有一些元数据和没有承诺的元数据。
Share 承诺 你要承诺好多东西。Coinbase 交易里面有一个 OP_RETURN 输出，可以承诺一些元数据。它描述了谁挖出了这个区块，这个矿工的收款地址，以及跟这个矿工联系所需的其它元数据。比如说还需要这个矿工的 IP 地址。一旦你挖出一个区块，你就成了 FROST 协议的一个参与者，这是用来签名支付的，所以你要跟其他矿工沟通。
Share 元数据 区块的元数据哈希后放到 coinbase 元数据中。Coinbase 交易会承诺在区块头中，同时 coinbase 交易有两个输出，一个是 OP_RETURN 输出，表示 braidpool 和这个承诺，另一个则是一个地址。这个地址是一个使用 FROST 和 Schnorr 签名的非常大的多签名地址。
最后，还有一些不带承诺的元数据。使用一个 DAG 的原因在于，我们希望让出块率尽可能高、出块尽可能快。而问题在于时延。我们使用 DAG，这样就能在同一时间有多个区块制造者。我们需要一个易于辨析的时间戳。比特币的时间戳字段很小，有时候矿工会用完。如果我们希望构造对图谱的度量，我们就需要毫秒级的精度。当你把一个区块头交给一个矿工之后，TA 通常会拿回去计算几秒钟甚至几分钟。等这个矿工拿着 Share 回来时，时间戳已经超时 10 秒钟了。我希望使用 DAG 来度量网络的时延。在比特币网络中，孤儿块（oprhans）率用来衡量网络的时延。</description></item><item><title>Misconceptions about segwit vbytes</title><link>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-segwit-vbytes-misconceptions/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-segwit-vbytes-misconceptions/</guid><description>度量交易的重量：见证数据的折扣 你应该已经从别人那里听到了，我的演讲会有更多个互动。我可能不会讲完我准备的所有内容。如果你在听的过程中有所疑惑，欢迎举手，这样我们就可以立即解决问题。我准备带各位了解一下非隔离见证交易和隔离见证交易的序列化。希望演讲结束之后，你可以理解交易的重量（weight） 是如何计算的，以及见证数据的折扣是如何适用的。最后，我们应该会看看一些不同的输出类型。
隔离见证以前 在隔离见证激活之前，一笔交易是这样的：它将至少有一个输入和一个输出。这笔交易有一个 P2PKH 输入，但有 4 个输出，一个是封装的隔离见证输入，一个是传统输入。到目前为止，没什么大不了的。估计你也看过这种类型的交易。
交易的序列化 打开引擎盖，我们来看得仔细些。如果你序列化一笔交易，或者观看一笔交易的序列化形式，就像 yogh.io 给不同数据染色一样，你可以看到，所有的数据都编码成十六进制的字符串，而且这些字符串是使用不同的函数来处理的。
我们首先会看到交易的元数据。每一笔交易都有一个 “交易头”，包含一个 4 字节的版本字段字段、输入容器（告诉你这笔交易有多少个输入）和输出容器（告诉你这笔交易有多少个输出），以及一个 4 字节的时间锁字段。
如果有人关注了最近关于 v3 交易的进展，这就是交易版本字段。如你所见，1 在最前面，因为这个值是小端序的（little-endian），不是大端序的（big-endian）。
看完交易头之后我们来看看输入。
输入的序列化 若我们要使用一个输入，我们首先必须告诉大家我们要花费的是哪个 UTXO。为了唯一地定位一个 UTXO，我们使用了 outpoint（“输出点”），就是一个交易索引号（txid）以及该 UTXO 在这个交易的输出列表中的位置。在我的幻灯片中，txid 是深蓝色的。这是这个 UTXO 的来源交易。作为计算机科学家，我们从 0 开始计数。
要花费一个 UTXO，我们必须满足编码在这个 UTXO 中的条件脚本。这是用 “输入脚本” 来作的。输入脚本的长度是任意的，取决于我们想要满足的脚本的条件类型。因此，我们必须将输入脚本的长度编码（“输入脚本长度”）进输入。
在这个数值之后就是输入脚本本身。以 P2PKH 输入为例，这是一种众所周知的脚本。P2PKH 条件脚本意味着资金被锁定在一个公钥的哈希值里。为了满足 P2PKH 脚本，我们要提供这个公钥，然后运行哈希计算，证明这个哈希值与存储在条件脚本里的一致，然后再提供该公钥的一个签名。
输入的最后一个字段是 “sequence”。使用这个字段，我们可以指定这笔交易是否可以被替换。一笔交易只要有一个输入的 sequence 值小于可能的最大值，这笔交易就不算是最终版本，是可以替换的。只需要在一个输入中指定，就足以让一笔交易变成可替换的。要是这个字段的值小于 最大值 - 1 呢？ 那就意味着它启用了时间锁。我在此不赘述了。
输出的序列化 这个示例交易有 4 个输出。我要拿出其中一个来细说。输出里的第一个字段是 “面额”，也就是进入这个锁定资金的条件脚本的聪的数量。一个输出会创建一个新的 UTXO，而一个 UTXO 会有确切的面额。然后，UTXO 还有一个锁定脚本，也就是条件脚本，指明可以花费这个 UTXO 的条件。
Q：你能在一笔交易中分配的最大数额是多少？
A：面额字段有 8 个字节长，所以我觉得它足以放下 2100 万 BTC。</description></item><item><title>Silent Payments and Alternatives</title><link>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-silent-payments/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-silent-payments/</guid><description>引言 我希望谈谈 “静默支付”，以及让你可以非交互地给他人支付的多种构造。在比特币的世界里，有许多常见的支付方式，发起支付是稀松平常的事。我们当前拥有的另类选择是，你可以生成一个地址然后放到你的 Twitter 介绍里，然后所有人都可以直接给你支付了，但这就没有隐私。所以，要么你需要在接收支付时跟发送者互动，要么你可以持续复用相同的地址，但要接受隐私性上的牺牲。
本演讲准备探究一下我们如何可以既做到非交互性，又能保留隐私性，也就是其他人无法在链上看到所有给我们的支付、知晓所有支付给同一个地址的资金。
出于这个目的，人们已经提出了很多协议了，但也有一些新出现的协议。我会展示其中的可能性。
给出一个 xpub 公钥 有一些方案我称之为 “准-交互式的解决方案”，意思是它们做不到无需交互，但交互量已经尽可能小了。其中一种非常基础的方案是，在你想给某人支付时，对方不是给你一个地址，而是给你一个新的 xpub 公钥，或者一个你可以从中生成许多地址的公钥。这样，你就不必在每次想要给这人支付时都请求一个新地址，只需最开始的一次交互就可以了（收款的地址你可以自己生成出来）。现在没有人会这样做，但我认为在有些时候，这样做也是合理的。对我来说，这样做会让事情变得简单一些。我遇到过好多次某个朋友想要跟我来回支付的情形，这时候获取新地址就会变成一个麻烦，因为他们可能需要回家拿到硬件钱包、生成一个新的地址，再交给我。如果只需交互一次，看起来会好一些。
这种方案的一个问题是（在恢复钱包时）会触发钱包的 “间隔限制（gap limit）” 。（译者注：你需要先理解 BIP32 才能理解这个问题。钱包遵循 BIP32，使用单个种子词根据递进的路径推导出数量没有上限的地址，从钱包内部来看，这些地址是 “连续的”。如果你在使用这些地址时没有严格保证逐个使用，就会在用过的地址之间出现 “间隔” —— 由没有用过的地址形成的队列。）因为你给出的 xpub 之间可能也有间隔，这个问题会比在交互式支付（你可以决定使用哪个地址）中更加严重。问题是这样的：如果你要持续给出地址，钱包工作的方式是从单个公钥为每次支付生成一个新地址；当你要从备份中恢复钱包时，你可以重复生成你可能用过的地址，然后到链上去，看看哪些地址已经用过了、带有余额；当钱包发现没有用过的地址的队列达到一定的长度时，就会假设扫描可以到此为止了（即假设剩下的将全部都是没有用过的地址，不可能具有余额），以免无穷无尽地扫描下去（译者注：也就是说，实际上，钱包不允许两个用过的地址之间出现太长的间隔）。但是，要是你给出了许许多多个地址，都没有被用过呢？当然，你可以暴力穷举，保证自己不会漏掉任何资金，但这是非常丑陋的。
在给出 xpub 的方案中，因为你给出的是一个 xpub，不同的 xpub 之间可能有未使用的，而每个 xpub 所推导的地址中也可能出现间隔（所以问题会更加严重）。一个观察是，如果你给了某人一个 xpub，当然在这个 xpub 推导出的地址中可以会有连续的未使用的地址，但是，请考虑一下，如果你可以假设持续给你支付的是同一个人，那就不会有很长的空白，因为没有理由需要留下很长的空白。还有一个假设是，你自己可以设法减少 xpub 之间的空白，从而补救这种情形。不同的 xpub 之间当然有空白，这取决于你是怎么给出这些 xpub 的。
直接给出 xpub 的方法对循环支付友好，但依然需要交互。依然需要一次交互。
自动化交互 另一类解决方案我称之为 “自动化交互”，就就是你运行一个服务端，然后服务器会帮你给出地址。这种方案需要一个安全的、始终在线的服务端，但在现实中，用户很难满足这种要求。这个房间里的开发者可以拍胸脯保证说这没什么难得，但普通用户会不得其门而入。
还有另一个严重的问题：依然难以保证未使用的地址不会形成长串。如果你设置了一个自动化的服务端，某些人可能会一直访问你的服务器并一直请求公钥。这很容易就会触发钱包的长度限制。所以，这个方案也没有解决间隔限制问题。
这种方案现在已经有了，比如 btcpay 服务端。我不知道他们是怎么处理间隔限制问题的。我认为他们会重新扫描一遍。我不知道他们有没有什么好办法，或者我可能漏掉了一些东西。
在现实中，已经有使用 btcpay 服务的商家了，但起码没有得到应该获得的接受程度。
免信任的地址服务器 还有一类我没有讲到的解决方案。我在最近的一篇邮件组帖子中称之为 “免信任的地址服务器”。它类似于 btcpay 服务端，但你不必自己运行服务端，你可以让别人来运行。关于为什么这是可行的，我的观察之一是，我们网络上有大量的轻客户端会给出公钥，有时候是 xpub，有时是自己生成的公钥，有时候把它们发送给一个服务端。面对帮助他们扫描区块链的服务端，他们已经丧失许多隐私性了。
如果我们已经有了一个服务端，并且知道他们可以让我们完全去匿名化并且觉得无所谓，为什么不依赖他们代表我们给出地址呢？
这里我们依然不能解决间隔控制问题。无论你自己运行服务器，还是别人帮助你，都有间隔控制问题。我有一个办法，但我们后面再说。所以，现在，你不是自己运行服务端，是别人运行服务端。一个新的问题出现了：要是服务端代表你给出了一个公钥，想要给你支付的人怎么确保那个公钥属于你呢？这个服务端完全可以尝试从中作梗，让支付者把钱打到他们的地址里去。
答案是，你可以为支付给你的人安排一个公钥，并使用这个公钥签名放在服务端的所有地址。我可以使用这个身份公钥签名我交给服务端的所有公钥（或者说地址）。现在，当某人想要从服务端获得地址时，他们得到的将不仅有地址，还有对地址的签名。这保证了服务端无法骗人，无法给出错误的地址。
在我们已经讲到的方法中，这是一种中庸的解决方案。它跟 btcpay 服务器只有细微的差别。而且其取舍也有趣。具体来说，这种方案假设，一些轻客户端已经在使用一种不完美的 —— 会把你的隐私暴露出去 —— 的方案了，所以也许会接受这种方案。我认为，因为这种隐私暴露，它不会是我们比特币社区想要的情形，但它们已经存在了，所以这种方案的取舍似乎也是合理的。</description></item><item><title>Provably bug-free BIPs and implementations using hac-spec</title><link>https://btctranscripts.com/zh/tabconf/2022/2022-10-14-hac-spec/</link><pubDate>Fri, 14 Oct 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2022/2022-10-14-hac-spec/</guid><description>https://nickler.ninja/
引言 我是 Jonas，我的演讲主题是 “可证明无硬伤（bug-free）的 BIP 及其实现”。我还没有写出这样的 BIP，更不用说这样的实现了，但如果你的时间偏好足够低，在未来的某一天，这样的 BIP 会出现的。我的演讲只有 15 分钟，有任何问题都请举手。
先补充一个背景。规范（specifications）就应该没有 bug，我们希望它易于实现、不容易被误解。这使得规范的编写成了一件缓慢而且吃力不讨好的事。
本演讲将介绍一个提升整个流程、使之更少出错的小步骤。
比特币升级提议 2 号 可能这里的许多人都熟悉 BIP2。BIP 应该长什么样？BIP 的流程应该怎么走？这都是在 BIP2 里面规范的，比如 “BIP 应该用 mediawiki 格式编写”。我猜，它也有自己的优点和缺点吧？但也还好。
结果，大部分的 BIP 都是用 mediawiki 格式编写的，但也有一些补充性的材料，比如图表，就不是 mediawiki 格式的。总体上使用 mediawiki 格式。MuSig BIP 是一套签名规范 —— 我们先不管它说了什么 —— 但可读性是可疑的，不太好。只能说也不太糟。 它包含一些伪代码，是我们编写的。我们只是编写了某种形式的伪代码，也许人们可以读懂。比如你看这里，sec_nonce 是斜体的，这意味着它是一个数字或者说变量，但这很难看出来。“出错应该尽可能明显（fail if that fails）” 是一个极为重要的原则，但在规范中很难做到。
另一个问题是正确性。这些伪代码显然无法在机器上执行，这意味着你没法为它们编写测试。即使 4 双、 6 双眼睛帮你看过了，也很难保证绝无错误，总可能有什么东西是大家都没注意到的。即使是 taproot BIP，也有各种各样的错误，比如位（bits）到整数（integers）的转换，等等。
难事一桩。我们必须花更多时间来改善这种情况，而这会让整个流程变得更慢。
参考代码 在 MuSig2 BIP 中，我们不止有伪代码，还有参考代码，是用 python 写的。Python 代码至少比伪代码好读，对实现者来说。事实上，它也是可以执行、可以测试的，我们设计了随机测试，还有测试界面，我们甚至使用了奇怪的 python 类型检查器（type-checker），来帮助发现 bug。看起来还好。
论文 同一种东西还有第三种表示，就是 MuSig2 论文。它好不好读我就不知道了，论文用的是数学符号，不是计算机可以立即处理的东西。</description></item><item><title>ROAST - Robust asynchronous Schnorr threshold signatures</title><link>https://btctranscripts.com/zh/tabconf/2022/2022-10-14-roast/</link><pubDate>Fri, 14 Oct 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2022/2022-10-14-roast/</guid><description>论文：https://ia.cr/2022/550
幻灯片：https://slides.com/real-or-random/roast-tabconf22/
哈咯各位，我叫 Tim，在 Blockstream 工作。本次演讲的内容是我跟几位合作者联合工作的成果。
比特币中的 Schnorr 签名 最近，我们已经在比特币中支持了 Schnorr 签名，由 taproot 软分叉激活的 BIP340 引入。我们希望引入 Schnorr 签名并倾向于使用它而不是 ECDSA，有三大理由：一，Schnorr 签名的安全性有明确的证明，可以给理论工作者更强的信心；二，Schnorr 签名效率更高；三，最主要是，在 Schnorr 上我们可以更容易构造更高级的签名协议。
想象 比特币已经支持 Shnorr 签名的验证。一旦我们把验证能力做进了协议，我们就可以在此基础上开发许多东西并应用在链上。举个例子，你可以开发门限签名，还可以实现像 MuSig 和 MuSig2 这样的多签名协议。只要一个签名看起来是一个 Schnorr 签名，你就可以把它放到链上，是可以兼容的。为了支持 Schnorr 签名，我们必须更改共识层。但是，一旦有了 Schnorr 签名，我们就不再需要为使用更高级的签名协议而改造共识层，这是个好事情，因为改变共识层更难。
此外，有了这些协议，假设你在链上看到了一个 Schnorr 签名，你并不能知道它是否使用了门限签名协议或者多签名协议。这也提供了紧凑性，无论在构造签名的过程中发生了什么，最终发送到链上的都只有 32 字节。这也很好，因为区块空间是稀缺的。
门限签名 可能你在之前听说过 “multisig（多签名）” 这个词。“Multisig” 这个词更多用在比特币工程社区中，而 “门限签名” 更多用在学术社区中。假定我们有一个 “t-of-n” 的门限签名设置，这意味着 n 个签名者共有一个公钥，并且至少要 t 个签名人在线，才能签发一条消息。作为一种特殊情况，的确有一种 n-of-n 的情况，需要所有签名者都在场，这在学术文献中称为 “多签名”。但在这里，我们的用词会灵活一点，然后我们就讨论 t-of-n 的情形。
不可伪造性是最主要的安全特性，也就是说 t 个签名人应该可以创建一个签名，但如果到场的不足 t 个人，就不应能够创建出签名，即使 (t-1) 个恶意签名人彼此串通，也无法生成有效的签名。另一个重要特性是健壮性（robustness）：要是 t 个签名人真的想创建一个签名，就一定能做到。这是一种抗 Dod 特性，即使 (t-1) （译者注：原文如此，疑应为 “(n - t)”）希望阻止签名，这 t 个签名人也能生成签名。这就是我们希望实现的几个主要特性。</description></item></channel></rss>