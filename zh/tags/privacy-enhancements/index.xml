<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>privacy-enhancements on ₿itcoin 记录稿</title><link>https://btctranscripts.com/zh/tags/privacy-enhancements/</link><description>Recent content in privacy-enhancements on ₿itcoin 记录稿</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 15 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://btctranscripts.com/zh/tags/privacy-enhancements/index.xml" rel="self" type="application/rss+xml"/><item><title>Silent Payments and Alternatives</title><link>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-silent-payments/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-silent-payments/</guid><description>引言 我希望谈谈 “静默支付”，以及让你可以非交互地给他人支付的多种构造。在比特币的世界里，有许多常见的支付方式，发起支付是稀松平常的事。我们当前拥有的另类选择是，你可以生成一个地址然后放到你的 Twitter 介绍里，然后所有人都可以直接给你支付了，但这就没有隐私。所以，要么你需要在接收支付时跟发送者互动，要么你可以持续复用相同的地址，但要接受隐私性上的牺牲。
本演讲准备探究一下我们如何可以既做到非交互性，又能保留隐私性，也就是其他人无法在链上看到所有给我们的支付、知晓所有支付给同一个地址的资金。
出于这个目的，人们已经提出了很多协议了，但也有一些新出现的协议。我会展示其中的可能性。
给出一个 xpub 公钥 有一些方案我称之为 “准-交互式的解决方案”，意思是它们做不到无需交互，但交互量已经尽可能小了。其中一种非常基础的方案是，在你想给某人支付时，对方不是给你一个地址，而是给你一个新的 xpub 公钥，或者一个你可以从中生成许多地址的公钥。这样，你就不必在每次想要给这人支付时都请求一个新地址，只需最开始的一次交互就可以了（收款的地址你可以自己生成出来）。现在没有人会这样做，但我认为在有些时候，这样做也是合理的。对我来说，这样做会让事情变得简单一些。我遇到过好多次某个朋友想要跟我来回支付的情形，这时候获取新地址就会变成一个麻烦，因为他们可能需要回家拿到硬件钱包、生成一个新的地址，再交给我。如果只需交互一次，看起来会好一些。
这种方案的一个问题是（在恢复钱包时）会触发钱包的 “间隔限制（gap limit）” 。（译者注：你需要先理解 BIP32 才能理解这个问题。钱包遵循 BIP32，使用单个种子词根据递进的路径推导出数量没有上限的地址，从钱包内部来看，这些地址是 “连续的”。如果你在使用这些地址时没有严格保证逐个使用，就会在用过的地址之间出现 “间隔” —— 由没有用过的地址形成的队列。）因为你给出的 xpub 之间可能也有间隔，这个问题会比在交互式支付（你可以决定使用哪个地址）中更加严重。问题是这样的：如果你要持续给出地址，钱包工作的方式是从单个公钥为每次支付生成一个新地址；当你要从备份中恢复钱包时，你可以重复生成你可能用过的地址，然后到链上去，看看哪些地址已经用过了、带有余额；当钱包发现没有用过的地址的队列达到一定的长度时，就会假设扫描可以到此为止了（即假设剩下的将全部都是没有用过的地址，不可能具有余额），以免无穷无尽地扫描下去（译者注：也就是说，实际上，钱包不允许两个用过的地址之间出现太长的间隔）。但是，要是你给出了许许多多个地址，都没有被用过呢？当然，你可以暴力穷举，保证自己不会漏掉任何资金，但这是非常丑陋的。
在给出 xpub 的方案中，因为你给出的是一个 xpub，不同的 xpub 之间可能有未使用的，而每个 xpub 所推导的地址中也可能出现间隔（所以问题会更加严重）。一个观察是，如果你给了某人一个 xpub，当然在这个 xpub 推导出的地址中可以会有连续的未使用的地址，但是，请考虑一下，如果你可以假设持续给你支付的是同一个人，那就不会有很长的空白，因为没有理由需要留下很长的空白。还有一个假设是，你自己可以设法减少 xpub 之间的空白，从而补救这种情形。不同的 xpub 之间当然有空白，这取决于你是怎么给出这些 xpub 的。
直接给出 xpub 的方法对循环支付友好，但依然需要交互。依然需要一次交互。
自动化交互 另一类解决方案我称之为 “自动化交互”，就就是你运行一个服务端，然后服务器会帮你给出地址。这种方案需要一个安全的、始终在线的服务端，但在现实中，用户很难满足这种要求。这个房间里的开发者可以拍胸脯保证说这没什么难得，但普通用户会不得其门而入。
还有另一个严重的问题：依然难以保证未使用的地址不会形成长串。如果你设置了一个自动化的服务端，某些人可能会一直访问你的服务器并一直请求公钥。这很容易就会触发钱包的长度限制。所以，这个方案也没有解决间隔限制问题。
这种方案现在已经有了，比如 btcpay 服务端。我不知道他们是怎么处理间隔限制问题的。我认为他们会重新扫描一遍。我不知道他们有没有什么好办法，或者我可能漏掉了一些东西。
在现实中，已经有使用 btcpay 服务的商家了，但起码没有得到应该获得的接受程度。
免信任的地址服务器 还有一类我没有讲到的解决方案。我在最近的一篇邮件组帖子中称之为 “免信任的地址服务器”。它类似于 btcpay 服务端，但你不必自己运行服务端，你可以让别人来运行。关于为什么这是可行的，我的观察之一是，我们网络上有大量的轻客户端会给出公钥，有时候是 xpub，有时是自己生成的公钥，有时候把它们发送给一个服务端。面对帮助他们扫描区块链的服务端，他们已经丧失许多隐私性了。
如果我们已经有了一个服务端，并且知道他们可以让我们完全去匿名化并且觉得无所谓，为什么不依赖他们代表我们给出地址呢？
这里我们依然不能解决间隔控制问题。无论你自己运行服务器，还是别人帮助你，都有间隔控制问题。我有一个办法，但我们后面再说。所以，现在，你不是自己运行服务端，是别人运行服务端。一个新的问题出现了：要是服务端代表你给出了一个公钥，想要给你支付的人怎么确保那个公钥属于你呢？这个服务端完全可以尝试从中作梗，让支付者把钱打到他们的地址里去。
答案是，你可以为支付给你的人安排一个公钥，并使用这个公钥签名放在服务端的所有地址。我可以使用这个身份公钥签名我交给服务端的所有公钥（或者说地址）。现在，当某人想要从服务端获得地址时，他们得到的将不仅有地址，还有对地址的签名。这保证了服务端无法骗人，无法给出错误的地址。
在我们已经讲到的方法中，这是一种中庸的解决方案。它跟 btcpay 服务器只有细微的差别。而且其取舍也有趣。具体来说，这种方案假设，一些轻客户端已经在使用一种不完美的 —— 会把你的隐私暴露出去 —— 的方案了，所以也许会接受这种方案。我认为，因为这种隐私暴露，它不会是我们比特币社区想要的情形，但它们已经存在了，所以这种方案的取舍似乎也是合理的。</description></item></channel></rss>