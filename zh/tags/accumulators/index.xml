<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>accumulators on ₿itcoin 记录稿</title><link>https://btctranscripts.com/zh/tags/accumulators/</link><description>Recent content in accumulators on ₿itcoin 记录稿</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Mon, 08 Oct 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://btctranscripts.com/zh/tags/accumulators/index.xml" rel="self" type="application/rss+xml"/><item><title>Utxo Accumulators And Utreexo</title><link>https://btctranscripts.com/zh/bitcoin-core-dev-tech/2018-10-08-utxo-accumulators-and-utreexo/</link><pubDate>Mon, 08 Oct 2018 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/bitcoin-core-dev-tech/2018-10-08-utxo-accumulators-and-utreexo/</guid><description>UTXO 累加器、UTXO 承诺与 Utreexo
https://twitter.com/kanzure/status/1049112390413897728
要是你听过 Benedikt 在两天以前的演讲，你应该能听出来，我们的演讲是有关联的。我们使用了不同的技术构造，但基本的目标是一样的。基本的想法就是 —— 我记得 Cory 在几个月前就在邮件组中讲到了 —— 不在 leveldb 数据库中存储所有的 UTXO，而是存储每一个 UTXO 的哈希值，仅此就可以将数据的体积减少一半；然后，你只需从输入的哈希值就能创建出它，这需要再多 10 字节左右。再然后，你也不必存储每一个 UTXO 的哈希值，你只需存储这些哈希值的一些压缩后的表达形式，然后用证据来传递它们。
在 Benedikt 的演讲中，这样的表达形式是基于 RSA 的累加器，或者可能是 “类群” 这种还完全没有得到验证的东西。我不了解。我在开发的是基于哈希值的累加器。虽说不同的累加器有不同的特性和操作，但一般来说，累加器的基本组成是：可以制作累加器的某种生成器；可以为累加器添加元素的 “添加” 操作，以及一种证明函数。生成器会返回一个累加器；而加操作则以一个已有的累加器和一个元素为输入，输出一个修改后的累加器；此外就是证明函数和验证函数，证明函数的作用是，假如我想证明某个元素存在于某个累加器中，函数会输出一个证据，而验证函数则以这样的证据和一个累加器作为输入，输出布尔值（是或否）。每一种累加器都至少有这三种函数，你需要能够添加、证明和验证。证明会产生证据，而验证测试则是某个证据对某个累加器的有效性。Alice 生成证据，Bob 检查证据的有效性。这就是最基本的构造。有的累加器还有一种证明某个元素不在其中的函数，得出的证据跟前面说的包含性证据不同，证明的是某个元素不在某个累加器中。有时候还会有一种 “删除” 操作，可以从某个累加器中删除某一个元素并返回一个修改后的累加器。
与此相关的第一篇论文提出了单向累加器，就是你可以一直向累加器添加元素，但你没法移除它们，它们会一直在哪里。其它类型的累加器就会有删除和证明非包含的功能。我要讲的这种累加器没有证明非包含的功能 —— 也许会有实现这种函数的办法，但可能会很丑陋。对于 UTXO 集来说，可能也不需要这种函数。
但也有一些理由会让你想拥有这些功能 —— 比如你想替代 leveldb。你准备不存储整个 UTXO 集合，仅存储这个累加器。每当有交易进来的时候，你就从你的累加器中删除一些元素并添加一些元素。每一笔交易的每一个输入，都有一个包含证据，然后你直接验证这个证据就行。这就是我正在思考的模式。它在比特币中可能还有别的应用场景，但我认为这个很酷，而且也会更快实现。
长期来说，累加器也有很好的作用，因为其背后的 UTXO 集的无限增长就没那么可怕了。一般来说，这些累加器和证据要么是固定大小的，要么是对数大小的。RSA 的累加器是固定大小的，我们用的是对数大小的。就算 UTXO 的数量增长到 100 亿个，也没问题。因为它将负担转移到了正确的地方。如果你是一个交易所，你拥有 2000 万个 UTXO，现在每个全节点都要在自己的 chainstate 文件夹中存储它们，但应用累加器之后，压力就转移到了交易所身上：他们要自己保存相关的证据，并向他人证明。
即使做不到这一点，即使只能做到将创建证据的负担转嫁到为每个人工作的节点上 —— 就像今天的节点为所有人都存储整条区块链 —— 依然有一些好处，因为我们为验证者移除了保管整个 UTXO 集的负担。矿工不再需要 UTXO 集，全节点也不再需要，而（创建证据）这样的服务你可以自己做，也可以交给别人来做，它并不对带宽敏感，速度慢也无所谓。每个区块都会有一个证据，从所有交易中组合出来。
不需要共识变更也可以实现，可以是 P2P 的。</description></item><item><title>Accumulators</title><link>https://btctranscripts.com/zh/scalingbitcoin/tokyo-2018/accumulators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/scalingbitcoin/tokyo-2018/accumulators/</guid><description>一种马上可用且可扩展的默克尔树替代品
https://twitter.com/kanzure/status/1048454406755168257
开场白 哈咯。声音测试。没问题。
我今天准备讲讲 UTXO 的累加器（accumulators）。前面的两场演讲给本演讲做了很好的铺垫。本演讲涉及的工作是我和 Ben Fisch（他今天也在这里）和 Dan Boneh 的联合成果。我还希望给 Stanford Blockchain Conference（曾用名 BPASE）打个广告，这个会将在 2019 年 1 月在斯坦福召开。无论你是否要去演讲，你都应该去看看。
UTXO UTXO 集的膨胀是一个日益严重的问题。今天上午我们已经听过了关于 UTXO 集合中的粉尘（译者注：指面额过于微小，因此无法单独花费的 UTXO）。我们已经有大约 6000 万个 UTXO。这里面的问题，我们在前几场演讲中已经听过了：区块链在存储 UTXO 上是非常低效的结构，如果我要下载一个旧区块，那么我需要知道当前区块与该旧区块之间的所有区块头。如果我想下载一笔旧交易并检查这笔交易是否已经花掉了，并且我只知道最新的区块，那么我需要检查从该交易到最新交易之间的所有交易，看看有没有哪一笔花费了它。
UTXO 承诺 有人提议用 UTXO 承诺来解决这个问题。就像我们刚刚听过的，每个区块都包含一个对最新状态（例如当前的 UTXO 集状态）的承诺。这里的想法是，利用共识规则来保证区块头中包含一个事实上正确的 UTXO 承诺。轻客户端将能够检查这个承诺。如果我想说服一个轻客户端某个 UTXO 是存在的，那么我需要给 TA 一个证据，证明它在最新的 UTXO 集承诺所涵盖的数据中。我们可以使用这种思路，将所有人都变成一个轻客户端。
默克尔树 实现这种思路的经典办法是 “默克尔树”。默克尔树的建构方法就像这样。我可以给你一个包含证据，证明 UTXO 集中含有某些东西；在生成包含证据时，需要 log(n) 次哈希计算，而且我可以在某些时候更新证据，每次更新都是 log(n)。
无状态的全节点 这样一来，我就能建构一种无状态的全节点，它不需要存储完整的 UTXO 集。这是怎么工作的呢？当我要发送一笔交易的时候，我必须提供一个证据，证明我的交易在花费一个还没有被花过的币。在当前，矿工用自己的 UTXO 集检查我的交易。但在这种设计中，由用户自己证明自己的币还没被花费过。因此，矿工将不必存储 UTXO 集，就能直接检查一笔交易是否被花费过。这很有趣。
默克尔树的问题 但这种方法有一些问题。主要的问题是，如果每一笔交易都要附加这些包含证据，它们的体积会变得非常大。每一笔交易都需要包含证据，那么区块链会需要额外的 160 GB 空间。并且，在验证区块链时，你需要做许多昂贵的检查。在 Peter Todd 提到这一点时，他提议仅对非常老旧的交易使用这种方法，而大部分交易不应该被逼迫使用这种技术。</description></item></channel></rss>