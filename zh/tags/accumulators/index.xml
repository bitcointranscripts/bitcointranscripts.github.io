<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>accumulators on ₿itcoin 记录稿</title><link>https://btctranscripts.com/zh/tags/accumulators/</link><description>Recent content in accumulators on ₿itcoin 记录稿</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://btctranscripts.com/zh/tags/accumulators/index.xml" rel="self" type="application/rss+xml"/><item><title>Accumulators</title><link>https://btctranscripts.com/zh/scalingbitcoin/tokyo-2018/accumulators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/scalingbitcoin/tokyo-2018/accumulators/</guid><description>一种马上可用且可扩展的默克尔树替代品
https://twitter.com/kanzure/status/1048454406755168257
开场白 哈咯。声音测试。没问题。
我今天准备讲讲 UTXO 的累加器（accumulators）。前面的两场演讲给本演讲做了很好的铺垫。本演讲涉及的工作是我和 Ben Fisch（他今天也在这里）和 Dan Boneh 的联合成果。我还希望给 Stanford Blockchain Conference（曾用名 BPASE）打个广告，这个会将在 2019 年 1 月在斯坦福召开。无论你是否要去演讲，你都应该去看看。
UTXO UTXO 集的膨胀是一个日益严重的问题。今天上午我们已经听过了关于 UTXO 集合中的粉尘（译者注：指面额过于微小，因此无法单独花费的 UTXO）。我们已经有大约 6000 万个 UTXO。这里面的问题，我们在前几场演讲中已经听过了：区块链在存储 UTXO 上是非常低效的结构，如果我要下载一个旧区块，那么我需要知道当前区块与该旧区块之间的所有区块头。如果我想下载一笔旧交易并检查这笔交易是否已经花掉了，并且我只知道最新的区块，那么我需要检查从该交易到最新交易之间的所有交易，看看有没有哪一笔花费了它。
UTXO 承诺 有人提议用 UTXO 承诺来解决这个问题。就像我们刚刚听过的，每个区块都包含一个对最新状态（例如当前的 UTXO 集状态）的承诺。这里的想法是，利用共识规则来保证区块头中包含一个事实上正确的 UTXO 承诺。轻客户端将能够检查这个承诺。如果我想说服一个轻客户端某个 UTXO 是存在的，那么我需要给 TA 一个证据，证明它在最新的 UTXO 集承诺所涵盖的数据中。我们可以使用这种思路，将所有人都变成一个轻客户端。
默克尔树 实现这种思路的经典办法是 “默克尔树”。默克尔树的建构方法就像这样。我可以给你一个包含证据，证明 UTXO 集中含有某些东西；在生成包含证据时，需要 log(n) 次哈希计算，而且我可以在某些时候更新证据，每次更新都是 log(n)。
无状态的全节点 这样一来，我就能建构一种无状态的全节点，它不需要存储完整的 UTXO 集。这是怎么工作的呢？当我要发送一笔交易的时候，我必须提供一个证据，证明我的交易在花费一个还没有被花过的币。在当前，矿工用自己的 UTXO 集检查我的交易。但在这种设计中，由用户自己证明自己的币还没被花费过。因此，矿工将不必存储 UTXO 集，就能直接检查一笔交易是否被花费过。这很有趣。
默克尔树的问题 但这种方法有一些问题。主要的问题是，如果每一笔交易都要附加这些包含证据，它们的体积会变得非常大。每一笔交易都需要包含证据，那么区块链会需要额外的 160 GB 空间。并且，在验证区块链时，你需要做许多昂贵的检查。在 Peter Todd 提到这一点时，他提议仅对非常老旧的交易使用这种方法，而大部分交易不应该被逼迫使用这种技术。</description></item></channel></rss>