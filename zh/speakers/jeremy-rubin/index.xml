<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jeremy Rubin on ₿itcoin 记录稿</title><link>https://btctranscripts.com/zh/speakers/jeremy-rubin/</link><description>Recent content in Jeremy Rubin on ₿itcoin 记录稿</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Fri, 05 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://btctranscripts.com/zh/speakers/jeremy-rubin/index.xml" rel="self" type="application/rss+xml"/><item><title>Covenants</title><link>https://btctranscripts.com/zh/tabconf/2021/2021-11-05-jeremy-rubin-andrew-poelstra-covenants/</link><pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2021/2021-11-05-jeremy-rubin-andrew-poelstra-covenants/</guid><description>主题：Covenants
场合：TABConf (The Atlanta Bitcoin Conference)
视频：互联网上无视频放出。
根据 “苏格拉底村” 规则，（除了演讲者之外）所有与会者都使用了假名；音频也不会公开，以保护提问者的匿名。
限制条款的概念 Shaun Apps（SA）：我先做个开场吧。Andrew 和 Jeremy 都会来。然后我们就以问答的形式开展，最后再回答观众的提问。这就是本场演讲的形式。
SA：言归正传，限制条款（covenant）。这个术语有宗教和法律方面的历史语境。大多数人理解的可能是物权法范畴内的概念，比如使用限制条款来约束土地的用途。但是，你们有多少人知道它在比特币领域内的意思？好的，看来很多人都听过。所以，基本上，限制条款给予了比特币脚本内省的能力，例如你可以通过预先定义的约束来限制一个输出的花费方式。我不太清楚限制条款的概念可以追溯到多久远以前。但是这一篇影响力很大的 BitcoinTalk 论坛帖子，作者是 Greg Maxwell，就介绍了限制条款的概念，并提出了一些假想的案例。举个例子，一种 Smashcoin 限制条款，在花费由此种条款锁定的资金时，必须提供攻击另一种密码货币的证据；甚至是一种 adultcoin 限制条款，必须提供某人的生日才能花费，它会限制接收者的年龄必须大于 18 岁。当然，这些都只是假设的、博君一笑的例子，这篇帖子也只是一个玩笑。但是，今天我们能够看到，限制条款有一些非常激动人心的用途。有请 Andrew Poelstra 和 Jeremy Rubin。Andrew 准备从 CHECKSIGFROMSTACK（也叫 “CSFS”）的视角出发，理解限制条款。Jeremy 的演讲则讨论 CHECKTEMPLATEVERIFY（也叫 “CTV”）。其实，有不止一种办法可以在比特币中实现限制条款。不同的想法、不同的提议，都有自己的取舍也应用场景。所以，我们来好好探究一番。Andrew，你想先来吗？
Andrew Poelstra（AP）：当然。如 Shaun 所说，某种程度上我代表着限制条款的 CHECKSIGFROMSTACK 流派。这种流派似乎代表着一种更普遍的视角。所以，为了帮助大家建立限制条款的概念 —— 我认为，这个概念确实肇始于那个 BitcoinTalk 帖子 …… 我不知道有什么讨论比这个更早 ……
Jeremy Rubin（JR）：那也是我所知最早的。
递归和非递归的限制条款 AP：有两种类型的限制条款，我把它们叫做 “递归型限制条款” 和 “非递归型限制条款”。我想这两个术语可能也源自那篇文章。“限制条款” 是且只是一种限制资金可以花到哪里去的办法。使用比特币脚本，你可以决定在什么条件下一笔资金可以移动，然而，一旦条件满足，资金就可以去任何地方。而限制条款则更进一步，允许你限制它的去向，实现上面说的种种傻事。
非递归的限制条款和递归的限制条款有一个区别。在非递归的限制条款中，你可以限制一笔资金的去向。你可以把它引到另一个限制条款中，从而进一步约束其去向，等等。但是，你必须规划出这笔资金的全部未来，你可以让它经历很多个限制条款，但你必须在一开始就把所有的限制条款写出来。递归型限制条款则不同，你可以让资金回到一个本质上与其来源相同的限制条款中；这就创造了一种有限的状态机，资金可以在不同的状态中移动。要么资金可以只待在一个地方，只是改变一些常数；要么它们可以移动到不同的状态，甚至它们可以返回原来的状态。凭借它，你可以创建一种让资金无法逃离的限制条款。甚至我的用词，“无法逃离”，也反映出其内在的危险性，同时也反映了许多年来人们对启用递归限制条款的恐惧。
不同的限制条款提议 AP：这些年出现了许多的限制条款提议。其中一个是 Jeremy Rubin 的 OP_CTV，曾用名 “OP_SECURETHEBAG”。在它的整个生命中，它有过多个名称，也经历了几次迭代。OP_CTV 被有意设计成规避递归型限制条款，以避免所有这些看似是玩笑、某个层面上又不是玩笑的东西。不过，另一种非常著名的限制条款提议，是非常通用的，它基于两种新的操作码，CHECKSIGFROMSTACK 和 CAT。 还有一种更为高效的变种，它增设的操作码可以直接检查正在花费这笔资金的交易。也就是说你可以直接把花费资金的交易本身拉取到堆栈中，然后执行你的脚本、直接地约束它们。一定程度上，你是在直接检查花费资金的交易、为之施加任意的约束。尤其是，如果你限制了交易的输出，那你就实现了一种递归型限制条款，可以永久困住这笔资金。这两种方法之间存在取舍。如果你尝试做一些事情来避免递归型限制条款 ……</description></item></channel></rss>