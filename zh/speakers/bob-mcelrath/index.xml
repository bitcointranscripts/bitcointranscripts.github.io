<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bob McElrath on ₿itcoin 记录稿</title><link>https://btctranscripts.com/zh/speakers/bob-mcelrath/</link><description>Recent content in Bob McElrath on ₿itcoin 记录稿</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 15 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://btctranscripts.com/zh/speakers/bob-mcelrath/index.xml" rel="self" type="application/rss+xml"/><item><title>Braidpool</title><link>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-braidpool/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-braidpool/</guid><description>引言 今天我准备讲讲 Braidpool，这是一种去中心化的矿池协议。希望在座有人参加了今天早些时候的矿业圆桌，尤其是关于 p2pool 的。Braidpool 是 p2pool 的后继者。很久以前我做过一次关于有向无环图（DAG）区块链的演讲。
Braidpool Braidpool 是一个去中心化的矿池提议，它使用了一个合并挖矿的 DAG 以及类中本聪的共识协议来跟踪矿工的贡献（shares）。这是我能够想象的最直接的在 DAG 上应用中本聪共识的想法。它保证了所有的矿工都会通过这个合并挖矿的另类区块链得到支付。它使用一套矿工的参与机制和一个很大的多签名机制（使用 FROST、ROAST 或者 MuSig2）来签名 coinbase 支付（或者说结算交易）。我们使用大规模多签名的能力，让这一切成为了可能。它会通过一个 “UTXO 集” 来跟踪矿池对矿工的欠款，这个 UTXO 实际上是一组交易（未花费的哈希化支付输出，Unspent Hasher Payment Output）。它瞄准的是参与者之间的恒定方差。每个矿工都有不同的挖矿难度，但我们希望为所有的矿工实现相同的出块率。它还允许发送矿工的贡献额，因此可以产生哈希率的期货和期权。可以是一个表示兆哈希（terahash）的币，你可以把它发送给别人，然后立即根据你提供的挖矿份额得到支付，或者基于此推出期货和期权。
大纲 有四个大类需要讨论。很久以前我曾经在推特上发表过我对这些分类的 “一般考量”。你必须定义什么是 shares（或者说 “准区块（weak blocks）”），然后你需要一种共识算法，我选择 Braid 是因为它的精神跟比特币最接近。然后你需要一种办法，将 coinbase （挖矿收益）合计到一笔滚动更新的交易中，表示（对矿工的）支付额的更新；最后，你需要签名，将收益支付给所有矿工。
Shares 在一个去中心化的矿池中，一个 “share” 就是一个准区块：一个完整的比特币区块，但不必然能满足比特币网络的出块难度。你从一个比特币区块开始，但这个区块并不必然能满足比特币网络的出块难度。这就是我要跟矿池中的其他所有人说明的事：我正在挖掘这个区块，要是我挖出了一个满足难度要求的区块，你们就会得到支付；我在遵守规则，要是我出了一个区块，你们会得到收益，反过来也如此，因为我们同在一个矿池中。支付交易按过往应该支付的数额滚动累加而成。还有一些元数据和没有承诺的元数据。
Share 承诺 你要承诺好多东西。Coinbase 交易里面有一个 OP_RETURN 输出，可以承诺一些元数据。它描述了谁挖出了这个区块，这个矿工的收款地址，以及跟这个矿工联系所需的其它元数据。比如说还需要这个矿工的 IP 地址。一旦你挖出一个区块，你就成了 FROST 协议的一个参与者，这是用来签名支付的，所以你要跟其他矿工沟通。
Share 元数据 区块的元数据哈希后放到 coinbase 元数据中。Coinbase 交易会承诺在区块头中，同时 coinbase 交易有两个输出，一个是 OP_RETURN 输出，表示 braidpool 和这个承诺，另一个则是一个地址。这个地址是一个使用 FROST 和 Schnorr 签名的非常大的多签名地址。
最后，还有一些不带承诺的元数据。使用一个 DAG 的原因在于，我们希望让出块率尽可能高、出块尽可能快。而问题在于时延。我们使用 DAG，这样就能在同一时间有多个区块制造者。我们需要一个易于辨析的时间戳。比特币的时间戳字段很小，有时候矿工会用完。如果我们希望构造对图谱的度量，我们就需要毫秒级的精度。当你把一个区块头交给一个矿工之后，TA 通常会拿回去计算几秒钟甚至几分钟。等这个矿工拿着 Share 回来时，时间戳已经超时 10 秒钟了。我希望使用 DAG 来度量网络的时延。在比特币网络中，孤儿块（oprhans）率用来衡量网络的时延。</description></item></channel></rss>