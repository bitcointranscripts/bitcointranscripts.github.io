<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>core-dev-tech on ₿itcoin 记录稿</title><link>https://btctranscripts.com/zh/categories/core-dev-tech/</link><description>Recent content in core-dev-tech on ₿itcoin 记录稿</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 15 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://btctranscripts.com/zh/categories/core-dev-tech/index.xml" rel="self" type="application/rss+xml"/><item><title>Silent Payments and Alternatives</title><link>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-silent-payments/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-silent-payments/</guid><description>引言 我希望谈谈 “静默支付”，以及让你可以非交互地给他人支付的多种构造。在比特币的世界里，有许多常见的支付方式，发起支付是稀松平常的事。我们当前拥有的另类选择是，你可以生成一个地址然后放到你的 Twitter 介绍里，然后所有人都可以直接给你支付了，但这就没有隐私。所以，要么你需要在接收支付时跟发送者互动，要么你可以持续复用相同的地址，但要接受隐私性上的牺牲。
本演讲准备探究一下我们如何可以既做到非交互性，又能保留隐私性，也就是其他人无法在链上看到所有给我们的支付、知晓所有支付给同一个地址的资金。
出于这个目的，人们已经提出了很多协议了，但也有一些新出现的协议。我会展示其中的可能性。
给出一个 xpub 公钥 有一些方案我称之为 “准-交互式的解决方案”，意思是它们做不到无需交互，但交互量已经尽可能小了。其中一种非常基础的方案是，在你想给某人支付时，对方不是给你一个地址，而是给你一个新的 xpub 公钥，或者一个你可以从中生成许多地址的公钥。这样，你就不必在每次想要给这人支付时都请求一个新地址，只需最开始的一次交互就可以了（收款的地址你可以自己生成出来）。现在没有人会这样做，但我认为在有些时候，这样做也是合理的。对我来说，这样做会让事情变得简单一些。我遇到过好多次某个朋友想要跟我来回支付的情形，这时候获取新地址就会变成一个麻烦，因为他们可能需要回家拿到硬件钱包、生成一个新的地址，再交给我。如果只需交互一次，看起来会好一些。
这种方案的一个问题是（在恢复钱包时）会触发钱包的 “间隔限制（gap limit）” 。（译者注：你需要先理解 BIP32 才能理解这个问题。钱包遵循 BIP32，使用单个种子词根据递进的路径推导出数量没有上限的地址，从钱包内部来看，这些地址是 “连续的”。如果你在使用这些地址时没有严格保证逐个使用，就会在用过的地址之间出现 “间隔” —— 由没有用过的地址形成的队列。）因为你给出的 xpub 之间可能也有间隔，这个问题会比在交互式支付（你可以决定使用哪个地址）中更加严重。问题是这样的：如果你要持续给出地址，钱包工作的方式是从单个公钥为每次支付生成一个新地址；当你要从备份中恢复钱包时，你可以重复生成你可能用过的地址，然后到链上去，看看哪些地址已经用过了、带有余额；当钱包发现没有用过的地址的队列达到一定的长度时，就会假设扫描可以到此为止了（即假设剩下的将全部都是没有用过的地址，不可能具有余额），以免无穷无尽地扫描下去（译者注：也就是说，实际上，钱包不允许两个用过的地址之间出现太长的间隔）。但是，要是你给出了许许多多个地址，都没有被用过呢？当然，你可以暴力穷举，保证自己不会漏掉任何资金，但这是非常丑陋的。
在给出 xpub 的方案中，因为你给出的是一个 xpub，不同的 xpub 之间可能有未使用的，而每个 xpub 所推导的地址中也可能出现间隔（所以问题会更加严重）。一个观察是，如果你给了某人一个 xpub，当然在这个 xpub 推导出的地址中可以会有连续的未使用的地址，但是，请考虑一下，如果你可以假设持续给你支付的是同一个人，那就不会有很长的空白，因为没有理由需要留下很长的空白。还有一个假设是，你自己可以设法减少 xpub 之间的空白，从而补救这种情形。不同的 xpub 之间当然有空白，这取决于你是怎么给出这些 xpub 的。
直接给出 xpub 的方法对循环支付友好，但依然需要交互。依然需要一次交互。
自动化交互 另一类解决方案我称之为 “自动化交互”，就就是你运行一个服务端，然后服务器会帮你给出地址。这种方案需要一个安全的、始终在线的服务端，但在现实中，用户很难满足这种要求。这个房间里的开发者可以拍胸脯保证说这没什么难得，但普通用户会不得其门而入。
还有另一个严重的问题：依然难以保证未使用的地址不会形成长串。如果你设置了一个自动化的服务端，某些人可能会一直访问你的服务器并一直请求公钥。这很容易就会触发钱包的长度限制。所以，这个方案也没有解决间隔限制问题。
这种方案现在已经有了，比如 btcpay 服务端。我不知道他们是怎么处理间隔限制问题的。我认为他们会重新扫描一遍。我不知道他们有没有什么好办法，或者我可能漏掉了一些东西。
在现实中，已经有使用 btcpay 服务的商家了，但起码没有得到应该获得的接受程度。
免信任的地址服务器 还有一类我没有讲到的解决方案。我在最近的一篇邮件组帖子中称之为 “免信任的地址服务器”。它类似于 btcpay 服务端，但你不必自己运行服务端，你可以让别人来运行。关于为什么这是可行的，我的观察之一是，我们网络上有大量的轻客户端会给出公钥，有时候是 xpub，有时是自己生成的公钥，有时候把它们发送给一个服务端。面对帮助他们扫描区块链的服务端，他们已经丧失许多隐私性了。
如果我们已经有了一个服务端，并且知道他们可以让我们完全去匿名化并且觉得无所谓，为什么不依赖他们代表我们给出地址呢？
这里我们依然不能解决间隔控制问题。无论你自己运行服务器，还是别人帮助你，都有间隔控制问题。我有一个办法，但我们后面再说。所以，现在，你不是自己运行服务端，是别人运行服务端。一个新的问题出现了：要是服务端代表你给出了一个公钥，想要给你支付的人怎么确保那个公钥属于你呢？这个服务端完全可以尝试从中作梗，让支付者把钱打到他们的地址里去。
答案是，你可以为支付给你的人安排一个公钥，并使用这个公钥签名放在服务端的所有地址。我可以使用这个身份公钥签名我交给服务端的所有公钥（或者说地址）。现在，当某人想要从服务端获得地址时，他们得到的将不仅有地址，还有对地址的签名。这保证了服务端无法骗人，无法给出错误的地址。
在我们已经讲到的方法中，这是一种中庸的解决方案。它跟 btcpay 服务器只有细微的差别。而且其取舍也有趣。具体来说，这种方案假设，一些轻客户端已经在使用一种不完美的 —— 会把你的隐私暴露出去 —— 的方案了，所以也许会接受这种方案。我认为，因为这种隐私暴露，它不会是我们比特币社区想要的情形，但它们已经存在了，所以这种方案的取舍似乎也是合理的。</description></item><item><title>Provably bug-free BIPs and implementations using hac-spec</title><link>https://btctranscripts.com/zh/tabconf/2022/2022-10-14-hac-spec/</link><pubDate>Fri, 14 Oct 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2022/2022-10-14-hac-spec/</guid><description>https://nickler.ninja/
引言 我是 Jonas，我的演讲主题是 “可证明无硬伤（bug-free）的 BIP 及其实现”。我还没有写出这样的 BIP，更不用说这样的实现了，但如果你的时间偏好足够低，在未来的某一天，这样的 BIP 会出现的。我的演讲只有 15 分钟，有任何问题都请举手。
先补充一个背景。规范（specifications）就应该没有 bug，我们希望它易于实现、不容易被误解。这使得规范的编写成了一件缓慢而且吃力不讨好的事。
本演讲将介绍一个提升整个流程、使之更少出错的小步骤。
比特币升级提议 2 号 可能这里的许多人都熟悉 BIP2。BIP 应该长什么样？BIP 的流程应该怎么走？这都是在 BIP2 里面规范的，比如 “BIP 应该用 mediawiki 格式编写”。我猜，它也有自己的优点和缺点吧？但也还好。
结果，大部分的 BIP 都是用 mediawiki 格式编写的，但也有一些补充性的材料，比如图表，就不是 mediawiki 格式的。总体上使用 mediawiki 格式。MuSig BIP 是一套签名规范 —— 我们先不管它说了什么 —— 但可读性是可疑的，不太好。只能说也不太糟。 它包含一些伪代码，是我们编写的。我们只是编写了某种形式的伪代码，也许人们可以读懂。比如你看这里，sec_nonce 是斜体的，这意味着它是一个数字或者说变量，但这很难看出来。“出错应该尽可能明显（fail if that fails）” 是一个极为重要的原则，但在规范中很难做到。
另一个问题是正确性。这些伪代码显然无法在机器上执行，这意味着你没法为它们编写测试。即使 4 双、 6 双眼睛帮你看过了，也很难保证绝无错误，总可能有什么东西是大家都没注意到的。即使是 taproot BIP，也有各种各样的错误，比如位（bits）到整数（integers）的转换，等等。
难事一桩。我们必须花更多时间来改善这种情况，而这会让整个流程变得更慢。
参考代码 在 MuSig2 BIP 中，我们不止有伪代码，还有参考代码，是用 python 写的。Python 代码至少比伪代码好读，对实现者来说。事实上，它也是可以执行、可以测试的，我们设计了随机测试，还有测试界面，我们甚至使用了奇怪的 python 类型检查器（type-checker），来帮助发现 bug。看起来还好。
论文 同一种东西还有第三种表示，就是 MuSig2 论文。它好不好读我就不知道了，论文用的是数学符号，不是计算机可以立即处理的东西。</description></item><item><title>UTXO accumulators, UTXO commitments, and Utreexo</title><link>https://btctranscripts.com/zh/bitcoin-core-dev-tech/2018-10/2018-10-08-utxo-accumulators-and-utreexo/</link><pubDate>Mon, 08 Oct 2018 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/bitcoin-core-dev-tech/2018-10/2018-10-08-utxo-accumulators-and-utreexo/</guid><description>UTXO 累加器、UTXO 承诺与 Utreexo
https://twitter.com/kanzure/status/1049112390413897728
要是你听过 Benedikt 在两天以前的演讲，你应该能听出来，我们的演讲是有关联的。我们使用了不同的技术构造，但基本的目标是一样的。基本的想法就是 —— 我记得 Cory 在几个月前就在邮件组中讲到了 —— 不在 leveldb 数据库中存储所有的 UTXO，而是存储每一个 UTXO 的哈希值，仅此就可以将数据的体积减少一半；然后，你只需从输入的哈希值就能创建出它，这需要再多 10 字节左右。再然后，你也不必存储每一个 UTXO 的哈希值，你只需存储这些哈希值的一些压缩后的表达形式，然后用证据来传递它们。
在 Benedikt 的演讲中，这样的表达形式是基于 RSA 的累加器，或者可能是 “类群” 这种还完全没有得到验证的东西。我不了解。我在开发的是基于哈希值的累加器。虽说不同的累加器有不同的特性和操作，但一般来说，累加器的基本组成是：可以制作累加器的某种生成器；可以为累加器添加元素的 “添加” 操作，以及一种证明函数。生成器会返回一个累加器；而加操作则以一个已有的累加器和一个元素为输入，输出一个修改后的累加器；此外就是证明函数和验证函数，证明函数的作用是，假如我想证明某个元素存在于某个累加器中，函数会输出一个证据，而验证函数则以这样的证据和一个累加器作为输入，输出布尔值（是或否）。每一种累加器都至少有这三种函数，你需要能够添加、证明和验证。证明会产生证据，而验证测试则是某个证据对某个累加器的有效性。Alice 生成证据，Bob 检查证据的有效性。这就是最基本的构造。有的累加器还有一种证明某个元素不在其中的函数，得出的证据跟前面说的包含性证据不同，证明的是某个元素不在某个累加器中。有时候还会有一种 “删除” 操作，可以从某个累加器中删除某一个元素并返回一个修改后的累加器。
与此相关的第一篇论文提出了单向累加器，就是你可以一直向累加器添加元素，但你没法移除它们，它们会一直在哪里。其它类型的累加器就会有删除和证明非包含的功能。我要讲的这种累加器没有证明非包含的功能 —— 也许会有实现这种函数的办法，但可能会很丑陋。对于 UTXO 集来说，可能也不需要这种函数。
但也有一些理由会让你想拥有这些功能 —— 比如你想替代 leveldb。你准备不存储整个 UTXO 集合，仅存储这个累加器。每当有交易进来的时候，你就从你的累加器中删除一些元素并添加一些元素。每一笔交易的每一个输入，都有一个包含证据，然后你直接验证这个证据就行。这就是我正在思考的模式。它在比特币中可能还有别的应用场景，但我认为这个很酷，而且也会更快实现。
长期来说，累加器也有很好的作用，因为其背后的 UTXO 集的无限增长就没那么可怕了。一般来说，这些累加器和证据要么是固定大小的，要么是对数大小的。RSA 的累加器是固定大小的，我们用的是对数大小的。就算 UTXO 的数量增长到 100 亿个，也没问题。因为它将负担转移到了正确的地方。如果你是一个交易所，你拥有 2000 万个 UTXO，现在每个全节点都要在自己的 chainstate 文件夹中存储它们，但应用累加器之后，压力就转移到了交易所身上：他们要自己保存相关的证据，并向他人证明。
即使做不到这一点，即使只能做到将创建证据的负担转嫁到为每个人工作的节点上 —— 就像今天的节点为所有人都存储整条区块链 —— 依然有一些好处，因为我们为验证者移除了保管整个 UTXO 集的负担。矿工不再需要 UTXO 集，全节点也不再需要，而（创建证据）这样的服务你可以自己做，也可以交给别人来做，它并不对带宽敏感，速度慢也无所谓。每个区块都会有一个证据，从所有交易中组合出来。
不需要共识变更也可以实现，可以是 P2P 的。</description></item></channel></rss>