<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hackathon on ₿itcoin 记录稿</title><link>https://btctranscripts.com/zh/categories/hackathon/</link><description>Recent content in hackathon on ₿itcoin 记录稿</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sun, 24 May 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://btctranscripts.com/zh/categories/hackathon/index.xml" rel="self" type="application/rss+xml"/><item><title>Watchtowers and BOLT 13</title><link>https://btctranscripts.com/zh/lightning-hack-day/2020-05-24-sergi-delgado-watchtowers/</link><pubDate>Sun, 24 May 2020 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/lightning-hack-day/2020-05-24-sergi-delgado-watchtowers/</guid><description>位置：Potzblitz（线上参与）
演示文档：https://srgi.me/resources/slides/Potzblitz!2020-Watchtowers.pdf
“中本聪之眼” 代码：https://github.com/talaia-labs/python-teos
BOLT 13 草案：https://github.com/sr-gi/bolt13/blob/master/13-watchtowers.md
c-lightning 瞭望塔插件：https://github.com/talaia-labs/python-teos/tree/master/watchtower-plugin
c-lightning 瞭望塔钩子讨论：
https://github.com/ElementsProject/lightning/pull/3601
https://github.com/ElementsProject/lightning/pull/3645
https://github.com/ElementsProject/lightning/pull/3659
https://github.com/ElementsProject/lightning/issues/3724
Conner Fromknecht 关于瞭望塔的演讲：https://diyhpl.us/wiki/transcripts/boltathon/2019-04-06-conner-fromknecht-watchtowers/
引言 我准备讲讲瞭望塔和 BOLT13。在讲解瞭望塔的细节之前 —— 虽然闪电网络瞭望塔的大体想法已经为社区的大部分人所知 —— 我准备先退一步，尝试缩小一下我们准备讨论的东西。
回顾 在我们思考瞭望塔的时候，我们想的是闪电通道 —— 瞭望塔可以在你的通道对手尝试欺诈、而你正好下线或遭遇宕机的时候，用带有惩罚的承诺交易保证对手不会成功。但瞭望塔还可以用在别的地方。今天我就准备讲这个话题。我们平时讲的第三方监控系统（即 “瞭望塔”）的基本范式是，用户和塔，也就是用户和服务端。用户将一些数据和触发条件发送给服务端。这里的数据是什么，并不重要，触发条件是什么也不重要。服务端会在特定的一个通信通道中寻找符合触发条件的东西。在闪电通道这个案例中，服务端会在区块链上搜寻，而在另一个案例中，可能是另一个完全不同的环境。只要服务端看到了符合触发条件的东西，瞭望塔就会拿用户提供的数据来执行一个动作。这就是我们今天准备讨论的东西，大体上就是这样。我们来看看闪电通道这个场景。
1 分钟讲解闪电通道交易 我假设这里的听众对闪电通道没有任何了解。我会讲讲闪电交易 —— 我们要使用什么样的交易，以及如何使用它们。
首先是闪电通道的充值交易。这是所有事情的起点。参与一条通道的双方中的其中一方，将资金锁入一个 2-of-2 的多签名输出中。然后，使用这笔交易（的输出），我们会创建多笔承诺交易，以表示通道内部状态的更新。每一次我们希望给对手方支付、或者对手方想给我们支付时，就会发生一次状态更新（创建一笔承诺交易）。所以，我们会有许多个不同版本的承诺交易，每一笔交易都花费同一笔资金（同一个输出）。如果万事顺利，到某个时间点，我们会使用一笔关闭交易来关闭通道。我们会拿最新一笔承诺交易来解锁资金，这笔交易就是 “关闭交易”。
但是，通道内可能有不轨行为，你的对手可能选择一笔旧的承诺交易并把它广播到网络上。这就是我们说的 “通道被破坏” 的情形。
假如 Alice 尝试欺诈，Bob 可以创建惩罚交易、拿走通道内所有的资金。如你所见，这里标注了两种交易：承诺交易和惩罚交易。这就是我们关心的东西。
基本的瞭望塔协议 有了这些理解，我们就可以建立一种基本的瞭望塔协议。这里有两方：一位是弗罗多（Frodo），你们可能听说过，他来自 中土世界（Middle Earth）；另一位是中本聪之眼（The Eye of Satoshi）。我不知道你们有没有听过《指环王》，但是弗罗多是个好人。
从用户的角度看，我们手上有一些数据。现在我们不会深究这些数据的细节，但请记住，承诺交易的 ID 以及惩罚交易，是其中一部分。我们将以某种形式保存这些数据。创建一个约定，我们将数据发给瞭望塔，瞭望塔开始监控区块链，观察通道被破坏的情形。这里我们也不会详细解释是怎么监控的，基本的思路就是说，瞭望塔得到用户的信息之后，就可以使用承诺交易的 ID 来监测打破通道的行为。弗罗多喜欢外出，可能跑到没有信号的地方去，几个小时不能响应。但幸好，中本聪之眼帮他看着所有这一切。在弗罗多下线的时候，中本聪之眼依然看着区块链。某一刻，中本聪之眼看到了某一笔承诺交易出现在了新挖出的区块上。这就表明，弗罗多的通道被打破了。中本聪之眼注意到了，然后就把惩罚交易发送到网络中，而且运气好的话只需几个区块就能确认惩罚交易。使用惩罚交易夺回的资金，大部分会归还给用户，小部分会发送给瞭望塔。关于其工作的原理，大体上到这里就结束了。我们有数据、触发条件、以及监视区块链的第三方观察者。
在这里，我们关心四件事：（1）用户所拥有的信息的类型。就是屏幕上左边的红色部分。承诺交易、惩罚交易以及如何用它们来创建跟瞭望塔的约定。也就是说，如何将它们发送给瞭望塔？（2）谁能发送这些信息，怎么发送？（3）瞭望塔应该怎么存储这些信息呢？存储什么类型，用什么方式？（4）奖励机制如何设计？这四个问题，实际上就是四种属性，是我认为在设计一个非托管的瞭望塔协议是需要面临的四种取舍。
现在，我们就要讲讲非托管的瞭望塔了。我们可以稍后再讲不同的设计。这样理解起来简单一些。
（非托管的）瞭望塔协议设计取舍 首先，我们要讲隐私性；换句话说，瞭望塔对自己的用户（一个闪电节点）到底知道什么？用户提供了什么信息，可以解读出什么？还有权限问题。谁能访问瞭望塔？谁能使用它，在何种条件下使用？第三件事是存储。瞭望塔必须存储什么信息？这些信息会如何增长？最后，我们还要考虑成本。运行瞭望塔服务的成本为何？谁为这些成本付费、分摊多少成本、如何支付？我们将看到，这四种属性是相互关联的。设计其一就会影响其余方面的设计。
没有隐私 vs. 完全隐私 我们先从隐私性开始。这里我们有两个极端。没有隐私性，以及，完全隐私。可以认为是存在中间路线的，但我先聚焦这两种情形。如果你们想要的话，我们再跳到中间路线的设计。
在这里，主要的思路是，用户可以选择完全不为瞭望塔设置隐私屏障，也就是把所有的信息都发送给瞭望塔。这意味着，整个装置跟我们在几页幻灯片以前看到的案例非常相似。用户清楚地发送承诺交易 ID 和惩罚交易给瞭望塔。这意味着，瞭望塔可以验证收到的信息看起来像一笔有效的交易、一个合理的交易 ID。虽然瞭望塔不能知道所收到的交易是正确的还是错误的，只能确定它看起来是一笔有效的交易；瞭望塔也不知道承诺交易的任何内容，只知道其交易 ID。瞭望塔也不知道惩罚交易会不会从某一点开始变成有效交易、能够广播到网络上，还是自始至终只是一笔完全无效的交易。最后，这种模式的缺点是，瞭望塔将知道关于用户的支付信息。每次通道状态更新的时候，瞭望塔都会知道对应的惩罚交易。这可以推断出每次更新的时候是哪一方在给哪一方支付。这显然不是理想状态。</description></item></channel></rss>