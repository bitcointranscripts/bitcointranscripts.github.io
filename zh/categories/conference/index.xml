<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>conference on ₿itcoin 记录稿</title><link>https://btctranscripts.com/zh/categories/conference/</link><description>Recent content in conference on ₿itcoin 记录稿</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Thu, 03 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://btctranscripts.com/zh/categories/conference/index.xml" rel="self" type="application/rss+xml"/><item><title>Miniscript</title><link>https://btctranscripts.com/zh/advancing-bitcoin/2022/2022-03-03-sanket-kanjalkar-miniscript/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/advancing-bitcoin/2022/2022-03-03-sanket-kanjalkar-miniscript/</guid><description>题目：Miniscript：可组合、可分析、更智能的比特币脚本
Andrew Poelstra 论 Miniscript：https://btctranscripts.com/london-bitcoin-devs/2020-02-04-andrew-poelstra-miniscript/
开场（Jeff Gallas） 下一个演讲者是 Sanket。他在 Blockstream 工作，主要开发 Simplicity 和 Miniscript。Miniscript 也是他今天演讲的主题。欢迎 Sanket ！
引言（Sanket Kanjalkar） 各位早上好！今天我想聊聊 Miniscript，这是 Pieter Wuille、Andrew Poelstra 和我的一项工作，也汇集了来自许多比特币人的想法。从 2019 年夏天以来，它一直在变化。但现在，它已经到了一个非常稳定的状态，可以分享出来、让更多人部署了。我的演讲题目是：“Miniscript：可组合、可分析、更智能的比特币脚本”。这是一个简单的背景介绍，如果你对哪一些内容有兴趣，欢迎在演讲结束后联系我，我们可以聊聊。
比特币 Script 当前的问题 为了介绍开发 Miniscript 的动机，我要先讲讲当前的比特币 Script 语言的问题。从非常抽象的层面来说，在中本聪设计比特币时，“不，我不要给某一个人支付，我要给这个人可以使用的一个基于脚本的程序支付” 的想法可谓石破天惊。
（译者注：“脚本（script）” 和 “Script” 两者时常混用，但仔细区分的话，前者指的是比特币 UTXO 的一个部分，用于为 UTXO 设置花费条件；而 Script 指的是一种特定的编写的脚本的方式 —— 直接使用实际需要执行的指令来编写脚本。）
今天的比特币 Script 给大家一个关于脚本的概念，脚本就是一些可以执行的指令（可以运行的程序），由网络中的所有参与者各自运行、检查某一笔交易是不是有效的。但从原理上说，其设计有一些问题。首先，它很难分析。我知道我们很多的比特币人都正确地宣传了其表达能力有限的事实，但就是这样有限的表达能力，我们也不知道如何分析脚本。除非我们部署像 Miniscript 这样的东西（这是一种更为通用、可组合的框架），不然比特币就还是给某个人支付而已。它很难用，而且几乎所有的工具都难用 —— 从 xpub 钱包到多签名。当我们说多签名的时候，我们还要跟一个复杂的词语联系起来，真遗憾。概念上来说，它其实不那么复杂。而且，在 Miniscript 中你拥有所有的定制化工具。比如你要使用 3-of-5 多签名，你想改变其中的某一些东西，那么你需要一个比特币专家来帮你分析你的改动。这是一个来自 BOLT 3（闪电网络 HTLC 规范之一）的例子。
OP_IF # 用于惩罚交易 &amp;lt;revocationpubkey&amp;gt; OP_ELSE `to_self_delay` # 自主决定的时间锁长度 OP_CHECKSEQUENCEVERIFY OP_DROP &amp;lt;local_delayedpubkey&amp;gt; OP_ENDIF OP_CHECKSIG 我们后面会讲解这个例子，这是一份原样复制的脚本，你很难看出来它想干什么。专家可以看懂这段脚本想干什么，但分辨起来并不容易。</description></item><item><title>Taproot on hardware wallets</title><link>https://btctranscripts.com/zh/advancing-bitcoin/2022/2022-03-03-stepan-snigirev-taproot-hardware-wallets/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/advancing-bitcoin/2022/2022-03-03-stepan-snigirev-taproot-hardware-wallets/</guid><description>开场（Jeff Gallas） 我非常高兴地宣布我们今天的第一位演讲者，来自 Specter 的 Stepan Snigirev，他是 Specter Solutions 的 CTO，有 3 年的开发比特币软件钱包（soft wallets）和硬件签名器（hard wallets）的经历。欢迎 Stepan。
概述（Stepan Snigirev） 我今天的演讲主题是 “在硬件签名器上支持 Taproot”。我们刚刚激活了 Taproot，非常棒，是在去年 11 月激活的。一些软件钱包已经开始集成了，而且甚至一些硬件签名器也开始集成了。现在大部分人用的都是单调的 “单密钥、单签名” 方案。我想讲讲我们可以用 Taproot 做什么。我觉得应该大家都知道了，所以我会讲快一点，然后我会讨论为什么在硬件签名器中集成 Taproot 是非常困难的、难点在哪里。如果我们无法在硬件钱包中集成，我们还有什么办法？
通过隐藏实现隐私 Taproot 非常出色。首先是它给了用户隐私性。在你观察区块链的时候，如果你看到一个单签名和单公钥的 taproot 地址，它里面可能实际上是一个公钥和一个脚本树。然后，这个公钥自身也可能凝结了一组公钥，而这棵脚本树可能非常高，是许许多多脚本的复杂集合。在里面你可以放置任意类型的时间锁，然后备份平时不会用到的私钥、仅在紧急情况下才启用它们。这意味着，所有复杂的花费条件，在链上看起来都是一样的。这是非常棒的事。甚至放在脚本中的公钥也可以代表着一组公钥，这就像是无限阶的密钥聚合。非常酷。
Miniscript（更安全的明文备份） 我个人会使用它的第一个理由是，它支持更好的明文备份。为什么现在没有人使用 Miniscript 或者复杂的比特币脚本？首先是因为比特币脚本复杂而不容易编写（在 Miniscript 出现之前）。其次是所有人都不使用它。这是一个鸡生蛋还是蛋生鸡的问题：每个人（90%）都使用单签名脚本，10% 的人使用多签名脚本，只有 0.3% 的人使用定制化的脚本。如果你使用一些定制化的脚本，你就暴露在了这 0.3% 里面。所有的链分析公司都知道，要是使用这样的脚本，那很有可能是同一个人。这样的隐私性非常糟，这就是障碍之一。
花费条件：or(HW, and(backup, timelock))
描述符：tr(HW, {and_v(v:pk(backup), older(timelock))})
Tapscript：&amp;lt;backup&amp;gt; OP_CHECKSIGVERIFY &amp;lt;timelock&amp;gt; OP_CHECKSEQUENCEVERIFY
（译者注：这段花费条件的意思是：一个硬件签名器随时可以花费这笔钱；同时，时间锁过期后，后备私钥也可以花费这笔钱。）
我个人会使用，我非常害怕把明文的钱包复原词（recovery phrases，应指种子词）放在我家里。如果有人得到了它，那我的钱就全部丢了。我个人的做法是使用一个不备份的硬件钱包，然后设置一个备用脚本，这个备用脚本带有时间锁，加上复原词就可以花费我的钱。然后，如果我遇到了什么意外，或者我的硬件钱包坏了，那么等待一段时间（也许半年）我就能拿回我的钱。但是，如果我的复原词被盗了，他们是没法立即偷走我的钱的（只要硬件钱包还在我手上的话）。我有足够多的时间，将资金迁移到一个新的装置上。但是，想想硬件签名器和 Miniscript 实现，现在还没有一个东西真正支持这个功能。太糟糕了。但实际上这并不是很难。在我给我们的硬件签名器集成 Miniscript 的时候，基本上我只花了一周的时间。我只要坐下来就可以开始开发了，因为它的说明真的写得非常好。Miniscript 有两个元素，其中一个你可以忽略，另一个是，如果你有一段可读的 policy 表达式，你就可以把它转成钱包的描述符。这有点复杂，但你不需要在硬件签名器里完成操作。第二部分是将钱包的描述符编译成实际的比特币脚本。这基本上只是把这些记号替换成比特币脚本的操作码，然后把派生出来的密钥放在正确的位置上。非常简单。然后硬件签名器就可以确定哪个输出是找零，并验证找零输出是从相同的描述符中派生出来的。这就行了。我想提一句，Ledger 团体最近做了很多工作来升级他们的比特币应用。他们在设计的时候就采用了 Miniscript 方法。虽然现在仅支持多签名功能，但很容易就能升级到支持定制化的 Miniscript，所以我很期待。至于硬件签名器，我不知道他们的计划。但至少会有两种硬件签名器将支持 Miniscript。</description></item><item><title>Transaction Relay Policy</title><link>https://btctranscripts.com/zh/adopting-bitcoin/2021/2021-11-16-gloria-zhao-transaction-relay-policy/</link><pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/adopting-bitcoin/2021/2021-11-16-gloria-zhao-transaction-relay-policy/</guid><description>主题：L2 开发者须知的交易转发规则
位置：Adopting Bitcoin
幻灯片：https://github.com/glozow/bitcoin-notes/blob/master/Tx%20Relay%20Policy%20for%20L2%20Devs%20-%20Adopting%20Bitcoin%202021.pdf&amp;gt;
引言 哈咯我是 Gloria，我在 Brink 公司为 Bitcoin Core 开发。今天我准备聊聊 “交易池规则（mempool policy）” 以及为什么你不能理所当然觉得你的交易会被广播、你的手续费追加方法要如何才能生效。我们正在做的事情就是要解决这些难题。如果你发现交易池有点难懂、不稳定、不可预期，你不确定自己的开发应用时能否放心使用交易池这个接口，这个演讲就是为你准备的。我猜大部分内容都对你有用。希望今天我们能让交易池变得更容易理解。
我的目标是让大家尽可能理解为交易的传播设置的各种限制。而我尝试的视角是作为一名比特币协议开发者的视角 —— 协议开发者如何思考交易池规则和交易转发策略。我接下来要定义什么是 “交易池规则”、我们如何分析它、问什么我们需要特定的策略并定义 “钉死攻击（pinning）”。我会从一些已知的限制开始，可能会清理一些关于攻击界面的误解。我还会提到一种对闪电通道的攻击。
我的目标是，在大家听完演讲之后，就能成为朋友，然后开始讨论如何在 Layer 1 和 Layer 2 之间开发通畅的桥梁。
任何人都能发送比特币支付 我想从头开始，确认我们对比特币的理解是一致的。我们想要比特币这样的系统，是为了让任何人都能把钱发给另一个人。这就是比特币的全部。
人们经常使用 “免准入（permissionless）” 和 “去中心化（decentralized）”、“免信任（trustless）” 这样的词来指称比特币。但可能一个更准确的框架是这样的。我们想要的第一个特性，是非常便宜就能运行一个节点。假如说 —— 我们举个例子哈 —— bitcoind 无法运行在 MacOS 上，或者它需要 32 GB 的内存、需要每月 2000 美元的代价才能运行一个全节点，那这对我们来说是不可接受的。我们希望它能运行在你的树莓派（Raspberry Pi）上，也就是很便宜的硬件就能运行。我们想要的另一个特性是 “抗审查性（censorship resistance）”，因为我们在尝试开发一个系统、帮助那些无法获得传统金融系统服务的人。如果我们开发出来的支付系统，很容易就能被某一些政府、富有的大银行、大公司任意审查他们不喜欢的交易，那我们就失败了。还有一种特性，显然，是安全性。在这个领域，我们不能依赖于某一些政府，由他们来确定 “这个节点在现实生活中就是这个人，他做了一些坏事，我们去起诉他”，我们没有这样的选择。我们希望每个人都能运行自己的节点，这是比特币的设计哲学中属于免信任性和去中心化的一部分。因此，安全也不是一个可选项，而是我们设计交易转发策略时候的首要考量。第四，我们不能强迫任何人运行比特币节点的一个新补丁，所以，当我们说某一个升级会优化用户的隐私性、但矿工的成本会变得更高、损失 50% 的收入或交易手续费会变得更高时，我们无法期待其他人会升级自己的节点。在讨论交易转发时，激励兼容也是一个始终需要考虑的东西。这就是我们思考这些事物的基本框架。
点对点的交易转发网络 希望这些对你来说并不意外，但是，要知道，在比特币中，我们需要在一个分布式的点对点网络中实现这些特性 —— 理想情况下，每个人都运行一个比特币节点、连接到比特币网络。这样的连接有许多形式：可能是你在自己的笔记本后台运行一个 bitcoind 程序、你安装了 Umbrel 或者 Raspiblitz 的树莓派小电脑，也可能是一个服务几千个智能手机钱包用户的大公司的服务器。所有这些都是一个比特币节点。它们本身非常不一样，但在点对点网络中，它们都是一个比特币节点。在你尝试给某人支付的时候，你要做的就是连接你的节点、提交你的交易、将交易广播给你的对等节点，希望这些对等节点会继续广播你的交易、最终将交易传播给某一个矿工。矿工会将交易打包到某个区块。
交易池 交易转发策略的真正关键的地方在于：每个参与交易转发的人都维护着一个交易池（mempool）。如果你想知道 “交易池” 的定义，我这里有一个：它是 “未确认的交易（unconfirmed transactions）” 的缓存（cache），并且是为了选出最为激励兼容（也即手续费率最高）的交易集合而专门优化的。这个优化方向不论对矿工还是非矿工都有意义，它帮助我们优雅地重组（re-org）、允许我们以更私密的方式设计交易转发策略，因为我们希望它比 “只懂 接受-转发” 更聪明一些。这是非常有用的，我在这个主题上写了许多东西。</description></item><item><title>Miniscript</title><link>https://btctranscripts.com/zh/tabconf/2021/2021-11-06-andrew-poelstra-miniscript/</link><pubDate>Sat, 06 Nov 2021 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2021/2021-11-06-andrew-poelstra-miniscript/</guid><description>主题：Miniscript：资金保管，可计算，可组合
场合：TABConf (The Atlanta Bitcoin Conference)
幻灯片：https://download.wpsoftware.net/bitcoin/wizardry/2021-11-tabconf/slides.pdf
引言 我准备讲讲 Miniscript。有些东西我之前就讲过，只不过讲述的方式更偏技术，侧重于讲解 Bitcoin Script 语言的困境、Miniscript 是什么、如何使用 Miniscript，等等。今天我准备从真正尝试使用比特币的人的角度谈谈 Miniscript，看看它是怎么解决这个行业中的一些我认为极为关键的问题的 —— 资金保管（custody）、密钥跟踪，等等。
在开始之前，我要先介绍一下本次演讲的结构。我准备花几页幻灯片稍微讲一讲比特币的脚本（bitcoin script）。比特币脚本是比特币内置的一个系统，用来定义资金的花费条件。一般来说，在普通的比特币钱包中，它使用的脚本的意思是 “为了移动这笔资金，交易需要提供某个公钥的签名”。这种脚本只是包在你的公钥上的薄薄的一层皮。但你还可以用脚本做出更有意思的东西。你可以指定，“这里有 3 个公钥，需要任意 2 个公钥的签名（才能花费这笔资金）”，比如说实现基于 2-of-3 多签名的保管方案。你还可以检查某个公钥在启用之前是否经过了特定的一段时间。你可以检查某个哈希值的原像是否被揭晓（这就是闪电网络的 HTLC 的工作原理）。所有这些巧妙的技术特性都可以在比特币脚本中实现。
但在现实中，有一些问题导致这些特性极难使用。结果就是当前的绝大部分比特币钱包完全不使用有趣的脚本。它们不单这么做，还做得彼此之间无法互通。
我想证明的正是，在 Bitcoin Script 以外，我们还有别的办法可以编写比特币的脚本；你可以使用这个被称为 “Miniscript” 的方法，获得一个易于分析的脚本编写框架。
资金保管是我持续关注的问题。你如何保管你的币？“可计算”，意味着有了 Miniscript，你可以分析你的脚本在做什么。你可以分辨出它的开销，因此可以作出准确的手续费估计。你可以确定你的脚本的语义特性。你还可以问这样的问题：“给定一些任意复杂的脚本，有人能不使用我的签名而使用这些脚本拿走我的资金吗？”对任何复杂的脚本我们都应该追问这个问题。在 Miniscript 之前，答案基本上就是：“我不知道。别用它。老实使用你知道的东西、老实沿用模板，老实使用大家分析过的东西。” 但有了 Miniscript ，你就可以编写任意复杂的脚本，同时依然能回答这个问题。第三个关键词是 “可组合”。这个很有趣，它本身是一个技术词汇，但它的前提非常直接。如果你有一个高级的花费方案（spending policy），但你想把其中的某一部分替换成一些复杂的东西，如果你只有 Bitcoin Script，你是无法轻易且可验证地做到的。但有了 Miniscript 你就可以做到。
一个例子是，你是一家公司的董事，这家公司持有大量比特币。你同意参与某种多签名方案，5 名董事中需要 4 位的签名才能移动资金。你是成员之一。现在其他人要求你提供一个公钥。但你不想给它们 一把 公钥，因为你可能会弄丢对应的私钥。你不把自己的比特币放在只有一个公钥控制的输出中也是同样的理由。你想要一些冗余，一些弹性。所以，理想情况下，你应该能表示 “在这个 4-of-5 方案中，我的部分将是一个 2-of-3 方案。我把这三个公钥放在了不同的地点，按不同的方式保护了起来。” 使用 Bitcoin Script 你是做不到的。如果某人向你请求一个公钥，而你回复以这样复杂的公钥组合和规则，收到信息的人以及参与同一个脚本的其他人都需要艰难地验证你这部分没有错。基本上，你做的事情就是提供一段脚本（一段计算机代码）、要求把这段代码插入到另一段计算机程序中，而这段程序的模式并不符合人们思考花费方案的方式。
Bitcoin Script 的问题 我这里有几张幻灯片列举了 Script 的问题。有一些是非常技术性的，只有钱包开发者才会在意。有一些则是每个人等应该关注的，尤其是前两个。</description></item><item><title>Covenants</title><link>https://btctranscripts.com/zh/tabconf/2021/2021-11-05-jeremy-rubin-andrew-poelstra-covenants/</link><pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2021/2021-11-05-jeremy-rubin-andrew-poelstra-covenants/</guid><description>主题：Covenants
场合：TABConf (The Atlanta Bitcoin Conference)
视频：互联网上无视频放出。
根据 “苏格拉底村” 规则，（除了演讲者之外）所有与会者都使用了假名；音频也不会公开，以保护提问者的匿名。
限制条款的概念 Shaun Apps（SA）：我先做个开场吧。Andrew 和 Jeremy 都会来。然后我们就以问答的形式开展，最后再回答观众的提问。这就是本场演讲的形式。
SA：言归正传，限制条款（covenant）。这个术语有宗教和法律方面的历史语境。大多数人理解的可能是物权法范畴内的概念，比如使用限制条款来约束土地的用途。但是，你们有多少人知道它在比特币领域内的意思？好的，看来很多人都听过。所以，基本上，限制条款给予了比特币脚本内省的能力，例如你可以通过预先定义的约束来限制一个输出的花费方式。我不太清楚限制条款的概念可以追溯到多久远以前。但是这一篇影响力很大的 BitcoinTalk 论坛帖子，作者是 Greg Maxwell，就介绍了限制条款的概念，并提出了一些假想的案例。举个例子，一种 Smashcoin 限制条款，在花费由此种条款锁定的资金时，必须提供攻击另一种密码货币的证据；甚至是一种 adultcoin 限制条款，必须提供某人的生日才能花费，它会限制接收者的年龄必须大于 18 岁。当然，这些都只是假设的、博君一笑的例子，这篇帖子也只是一个玩笑。但是，今天我们能够看到，限制条款有一些非常激动人心的用途。有请 Andrew Poelstra 和 Jeremy Rubin。Andrew 准备从 CHECKSIGFROMSTACK（也叫 “CSFS”）的视角出发，理解限制条款。Jeremy 的演讲则讨论 CHECKTEMPLATEVERIFY（也叫 “CTV”）。其实，有不止一种办法可以在比特币中实现限制条款。不同的想法、不同的提议，都有自己的取舍也应用场景。所以，我们来好好探究一番。Andrew，你想先来吗？
Andrew Poelstra（AP）：当然。如 Shaun 所说，某种程度上我代表着限制条款的 CHECKSIGFROMSTACK 流派。这种流派似乎代表着一种更普遍的视角。所以，为了帮助大家建立限制条款的概念 —— 我认为，这个概念确实肇始于那个 BitcoinTalk 帖子 …… 我不知道有什么讨论比这个更早 ……
Jeremy Rubin（JR）：那也是我所知最早的。
递归和非递归的限制条款 AP：有两种类型的限制条款，我把它们叫做 “递归型限制条款” 和 “非递归型限制条款”。我想这两个术语可能也源自那篇文章。“限制条款” 是且只是一种限制资金可以花到哪里去的办法。使用比特币脚本，你可以决定在什么条件下一笔资金可以移动，然而，一旦条件满足，资金就可以去任何地方。而限制条款则更进一步，允许你限制它的去向，实现上面说的种种傻事。
非递归的限制条款和递归的限制条款有一个区别。在非递归的限制条款中，你可以限制一笔资金的去向。你可以把它引到另一个限制条款中，从而进一步约束其去向，等等。但是，你必须规划出这笔资金的全部未来，你可以让它经历很多个限制条款，但你必须在一开始就把所有的限制条款写出来。递归型限制条款则不同，你可以让资金回到一个本质上与其来源相同的限制条款中；这就创造了一种有限的状态机，资金可以在不同的状态中移动。要么资金可以只待在一个地方，只是改变一些常数；要么它们可以移动到不同的状态，甚至它们可以返回原来的状态。凭借它，你可以创建一种让资金无法逃离的限制条款。甚至我的用词，“无法逃离”，也反映出其内在的危险性，同时也反映了许多年来人们对启用递归限制条款的恐惧。
不同的限制条款提议 AP：这些年出现了许多的限制条款提议。其中一个是 Jeremy Rubin 的 OP_CTV，曾用名 “OP_SECURETHEBAG”。在它的整个生命中，它有过多个名称，也经历了几次迭代。OP_CTV 被有意设计成规避递归型限制条款，以避免所有这些看似是玩笑、某个层面上又不是玩笑的东西。不过，另一种非常著名的限制条款提议，是非常通用的，它基于两种新的操作码，CHECKSIGFROMSTACK 和 CAT。 还有一种更为高效的变种，它增设的操作码可以直接检查正在花费这笔资金的交易。也就是说你可以直接把花费资金的交易本身拉取到堆栈中，然后执行你的脚本、直接地约束它们。一定程度上，你是在直接检查花费资金的交易、为之施加任意的约束。尤其是，如果你限制了交易的输出，那你就实现了一种递归型限制条款，可以永久困住这笔资金。这两种方法之间存在取舍。如果你尝试做一些事情来避免递归型限制条款 ……</description></item><item><title>Accumulators</title><link>https://btctranscripts.com/zh/scalingbitcoin/tokyo-2018/accumulators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/scalingbitcoin/tokyo-2018/accumulators/</guid><description>一种马上可用且可扩展的默克尔树替代品
https://twitter.com/kanzure/status/1048454406755168257
开场白 哈咯。声音测试。没问题。
我今天准备讲讲 UTXO 的累加器（accumulators）。前面的两场演讲给本演讲做了很好的铺垫。本演讲涉及的工作是我和 Ben Fisch（他今天也在这里）和 Dan Boneh 的联合成果。我还希望给 Stanford Blockchain Conference（曾用名 BPASE）打个广告，这个会将在 2019 年 1 月在斯坦福召开。无论你是否要去演讲，你都应该去看看。
UTXO UTXO 集的膨胀是一个日益严重的问题。今天上午我们已经听过了关于 UTXO 集合中的粉尘（译者注：指面额过于微小，因此无法单独花费的 UTXO）。我们已经有大约 6000 万个 UTXO。这里面的问题，我们在前几场演讲中已经听过了：区块链在存储 UTXO 上是非常低效的结构，如果我要下载一个旧区块，那么我需要知道当前区块与该旧区块之间的所有区块头。如果我想下载一笔旧交易并检查这笔交易是否已经花掉了，并且我只知道最新的区块，那么我需要检查从该交易到最新交易之间的所有交易，看看有没有哪一笔花费了它。
UTXO 承诺 有人提议用 UTXO 承诺来解决这个问题。就像我们刚刚听过的，每个区块都包含一个对最新状态（例如当前的 UTXO 集状态）的承诺。这里的想法是，利用共识规则来保证区块头中包含一个事实上正确的 UTXO 承诺。轻客户端将能够检查这个承诺。如果我想说服一个轻客户端某个 UTXO 是存在的，那么我需要给 TA 一个证据，证明它在最新的 UTXO 集承诺所涵盖的数据中。我们可以使用这种思路，将所有人都变成一个轻客户端。
默克尔树 实现这种思路的经典办法是 “默克尔树”。默克尔树的建构方法就像这样。我可以给你一个包含证据，证明 UTXO 集中含有某些东西；在生成包含证据时，需要 log(n) 次哈希计算，而且我可以在某些时候更新证据，每次更新都是 log(n)。
无状态的全节点 这样一来，我就能建构一种无状态的全节点，它不需要存储完整的 UTXO 集。这是怎么工作的呢？当我要发送一笔交易的时候，我必须提供一个证据，证明我的交易在花费一个还没有被花过的币。在当前，矿工用自己的 UTXO 集检查我的交易。但在这种设计中，由用户自己证明自己的币还没被花费过。因此，矿工将不必存储 UTXO 集，就能直接检查一笔交易是否被花费过。这很有趣。
默克尔树的问题 但这种方法有一些问题。主要的问题是，如果每一笔交易都要附加这些包含证据，它们的体积会变得非常大。每一笔交易都需要包含证据，那么区块链会需要额外的 160 GB 空间。并且，在验证区块链时，你需要做许多昂贵的检查。在 Peter Todd 提到这一点时，他提议仅对非常老旧的交易使用这种方法，而大部分交易不应该被逼迫使用这种技术。</description></item></channel></rss>