<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>conference on ₿itcoin 记录稿</title><link>https://btctranscripts.com/zh/categories/conference/</link><description>Recent content in conference on ₿itcoin 记录稿</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 15 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://btctranscripts.com/zh/categories/conference/index.xml" rel="self" type="application/rss+xml"/><item><title>Braidpool</title><link>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-braidpool/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-braidpool/</guid><description>引言 今天我准备讲讲 Braidpool，这是一种去中心化的矿池协议。希望在座有人参加了今天早些时候的矿业圆桌，尤其是关于 p2pool 的。Braidpool 是 p2pool 的后继者。很久以前我做过一次关于有向无环图（DAG）区块链的演讲。
Braidpool Braidpool 是一个去中心化的矿池提议，它使用了一个合并挖矿的 DAG 以及类中本聪的共识协议来跟踪矿工的贡献（shares）。这是我能够想象的最直接的在 DAG 上应用中本聪共识的想法。它保证了所有的矿工都会通过这个合并挖矿的另类区块链得到支付。它使用一套矿工的参与机制和一个很大的多签名机制（使用 FROST、ROAST 或者 MuSig2）来签名 coinbase 支付（或者说结算交易）。我们使用大规模多签名的能力，让这一切成为了可能。它会通过一个 “UTXO 集” 来跟踪矿池对矿工的欠款，这个 UTXO 实际上是一组交易（未花费的哈希化支付输出，Unspent Hasher Payment Output）。它瞄准的是参与者之间的恒定方差。每个矿工都有不同的挖矿难度，但我们希望为所有的矿工实现相同的出块率。它还允许发送矿工的贡献额，因此可以产生哈希率的期货和期权。可以是一个表示兆哈希（terahash）的币，你可以把它发送给别人，然后立即根据你提供的挖矿份额得到支付，或者基于此推出期货和期权。
大纲 有四个大类需要讨论。很久以前我曾经在推特上发表过我对这些分类的 “一般考量”。你必须定义什么是 shares（或者说 “准区块（weak blocks）”），然后你需要一种共识算法，我选择 Braid 是因为它的精神跟比特币最接近。然后你需要一种办法，将 coinbase （挖矿收益）合计到一笔滚动更新的交易中，表示（对矿工的）支付额的更新；最后，你需要签名，将收益支付给所有矿工。
Shares 在一个去中心化的矿池中，一个 “share” 就是一个准区块：一个完整的比特币区块，但不必然能满足比特币网络的出块难度。你从一个比特币区块开始，但这个区块并不必然能满足比特币网络的出块难度。这就是我要跟矿池中的其他所有人说明的事：我正在挖掘这个区块，要是我挖出了一个满足难度要求的区块，你们就会得到支付；我在遵守规则，要是我出了一个区块，你们会得到收益，反过来也如此，因为我们同在一个矿池中。支付交易按过往应该支付的数额滚动累加而成。还有一些元数据和没有承诺的元数据。
Share 承诺 你要承诺好多东西。Coinbase 交易里面有一个 OP_RETURN 输出，可以承诺一些元数据。它描述了谁挖出了这个区块，这个矿工的收款地址，以及跟这个矿工联系所需的其它元数据。比如说还需要这个矿工的 IP 地址。一旦你挖出一个区块，你就成了 FROST 协议的一个参与者，这是用来签名支付的，所以你要跟其他矿工沟通。
Share 元数据 区块的元数据哈希后放到 coinbase 元数据中。Coinbase 交易会承诺在区块头中，同时 coinbase 交易有两个输出，一个是 OP_RETURN 输出，表示 braidpool 和这个承诺，另一个则是一个地址。这个地址是一个使用 FROST 和 Schnorr 签名的非常大的多签名地址。
最后，还有一些不带承诺的元数据。使用一个 DAG 的原因在于，我们希望让出块率尽可能高、出块尽可能快。而问题在于时延。我们使用 DAG，这样就能在同一时间有多个区块制造者。我们需要一个易于辨析的时间戳。比特币的时间戳字段很小，有时候矿工会用完。如果我们希望构造对图谱的度量，我们就需要毫秒级的精度。当你把一个区块头交给一个矿工之后，TA 通常会拿回去计算几秒钟甚至几分钟。等这个矿工拿着 Share 回来时，时间戳已经超时 10 秒钟了。我希望使用 DAG 来度量网络的时延。在比特币网络中，孤儿块（oprhans）率用来衡量网络的时延。</description></item><item><title>Misconceptions about segwit vbytes</title><link>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-segwit-vbytes-misconceptions/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2022/2022-10-15-segwit-vbytes-misconceptions/</guid><description>度量交易的重量：见证数据的折扣 你应该已经从别人那里听到了，我的演讲会有更多个互动。我可能不会讲完我准备的所有内容。如果你在听的过程中有所疑惑，欢迎举手，这样我们就可以立即解决问题。我准备带各位了解一下非隔离见证交易和隔离见证交易的序列化。希望演讲结束之后，你可以理解交易的重量（weight） 是如何计算的，以及见证数据的折扣是如何适用的。最后，我们应该会看看一些不同的输出类型。
隔离见证以前 在隔离见证激活之前，一笔交易是这样的：它将至少有一个输入和一个输出。这笔交易有一个 P2PKH 输入，但有 4 个输出，一个是封装的隔离见证输入，一个是传统输入。到目前为止，没什么大不了的。估计你也看过这种类型的交易。
交易的序列化 打开引擎盖，我们来看得仔细些。如果你序列化一笔交易，或者观看一笔交易的序列化形式，就像 yogh.io 给不同数据染色一样，你可以看到，所有的数据都编码成十六进制的字符串，而且这些字符串是使用不同的函数来处理的。
我们首先会看到交易的元数据。每一笔交易都有一个 “交易头”，包含一个 4 字节的版本字段字段、输入容器（告诉你这笔交易有多少个输入）和输出容器（告诉你这笔交易有多少个输出），以及一个 4 字节的时间锁字段。
如果有人关注了最近关于 v3 交易的进展，这就是交易版本字段。如你所见，1 在最前面，因为这个值是小端序的（little-endian），不是大端序的（big-endian）。
看完交易头之后我们来看看输入。
输入的序列化 若我们要使用一个输入，我们首先必须告诉大家我们要花费的是哪个 UTXO。为了唯一地定位一个 UTXO，我们使用了 outpoint（“输出点”），就是一个交易索引号（txid）以及该 UTXO 在这个交易的输出列表中的位置。在我的幻灯片中，txid 是深蓝色的。这是这个 UTXO 的来源交易。作为计算机科学家，我们从 0 开始计数。
要花费一个 UTXO，我们必须满足编码在这个 UTXO 中的条件脚本。这是用 “输入脚本” 来作的。输入脚本的长度是任意的，取决于我们想要满足的脚本的条件类型。因此，我们必须将输入脚本的长度编码（“输入脚本长度”）进输入。
在这个数值之后就是输入脚本本身。以 P2PKH 输入为例，这是一种众所周知的脚本。P2PKH 条件脚本意味着资金被锁定在一个公钥的哈希值里。为了满足 P2PKH 脚本，我们要提供这个公钥，然后运行哈希计算，证明这个哈希值与存储在条件脚本里的一致，然后再提供该公钥的一个签名。
输入的最后一个字段是 “sequence”。使用这个字段，我们可以指定这笔交易是否可以被替换。一笔交易只要有一个输入的 sequence 值小于可能的最大值，这笔交易就不算是最终版本，是可以替换的。只需要在一个输入中指定，就足以让一笔交易变成可替换的。要是这个字段的值小于 最大值 - 1 呢？ 那就意味着它启用了时间锁。我在此不赘述了。
输出的序列化 这个示例交易有 4 个输出。我要拿出其中一个来细说。输出里的第一个字段是 “面额”，也就是进入这个锁定资金的条件脚本的聪的数量。一个输出会创建一个新的 UTXO，而一个 UTXO 会有确切的面额。然后，UTXO 还有一个锁定脚本，也就是条件脚本，指明可以花费这个 UTXO 的条件。
Q：你能在一笔交易中分配的最大数额是多少？
A：面额字段有 8 个字节长，所以我觉得它足以放下 2100 万 BTC。</description></item><item><title>ROAST - Robust asynchronous Schnorr threshold signatures</title><link>https://btctranscripts.com/zh/tabconf/2022/2022-10-14-roast/</link><pubDate>Fri, 14 Oct 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2022/2022-10-14-roast/</guid><description>论文：https://ia.cr/2022/550
幻灯片：https://slides.com/real-or-random/roast-tabconf22/
哈咯各位，我叫 Tim，在 Blockstream 工作。本次演讲的内容是我跟几位合作者联合工作的成果。
比特币中的 Schnorr 签名 最近，我们已经在比特币中支持了 Schnorr 签名，由 taproot 软分叉激活的 BIP340 引入。我们希望引入 Schnorr 签名并倾向于使用它而不是 ECDSA，有三大理由：一，Schnorr 签名的安全性有明确的证明，可以给理论工作者更强的信心；二，Schnorr 签名效率更高；三，最主要是，在 Schnorr 上我们可以更容易构造更高级的签名协议。
想象 比特币已经支持 Shnorr 签名的验证。一旦我们把验证能力做进了协议，我们就可以在此基础上开发许多东西并应用在链上。举个例子，你可以开发门限签名，还可以实现像 MuSig 和 MuSig2 这样的多签名协议。只要一个签名看起来是一个 Schnorr 签名，你就可以把它放到链上，是可以兼容的。为了支持 Schnorr 签名，我们必须更改共识层。但是，一旦有了 Schnorr 签名，我们就不再需要为使用更高级的签名协议而改造共识层，这是个好事情，因为改变共识层更难。
此外，有了这些协议，假设你在链上看到了一个 Schnorr 签名，你并不能知道它是否使用了门限签名协议或者多签名协议。这也提供了紧凑性，无论在构造签名的过程中发生了什么，最终发送到链上的都只有 32 字节。这也很好，因为区块空间是稀缺的。
门限签名 可能你在之前听说过 “multisig（多签名）” 这个词。“Multisig” 这个词更多用在比特币工程社区中，而 “门限签名” 更多用在学术社区中。假定我们有一个 “t-of-n” 的门限签名设置，这意味着 n 个签名者共有一个公钥，并且至少要 t 个签名人在线，才能签发一条消息。作为一种特殊情况，的确有一种 n-of-n 的情况，需要所有签名者都在场，这在学术文献中称为 “多签名”。但在这里，我们的用词会灵活一点，然后我们就讨论 t-of-n 的情形。
不可伪造性是最主要的安全特性，也就是说 t 个签名人应该可以创建一个签名，但如果到场的不足 t 个人，就不应能够创建出签名，即使 (t-1) 个恶意签名人彼此串通，也无法生成有效的签名。另一个重要特性是健壮性（robustness）：要是 t 个签名人真的想创建一个签名，就一定能做到。这是一种抗 Dod 特性，即使 (t-1) （译者注：原文如此，疑应为 “(n - t)”）希望阻止签名，这 t 个签名人也能生成签名。这就是我们希望实现的几个主要特性。</description></item><item><title>Miniscript</title><link>https://btctranscripts.com/zh/advancing-bitcoin/2022/2022-03-03-sanket-kanjalkar-miniscript/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/advancing-bitcoin/2022/2022-03-03-sanket-kanjalkar-miniscript/</guid><description>题目：Miniscript：可组合、可分析、更智能的比特币脚本
Andrew Poelstra 论 Miniscript：https://btctranscripts.com/london-bitcoin-devs/2020-02-04-andrew-poelstra-miniscript/
开场（Jeff Gallas） 下一个演讲者是 Sanket。他在 Blockstream 工作，主要开发 Simplicity 和 Miniscript。Miniscript 也是他今天演讲的主题。欢迎 Sanket ！
引言（Sanket Kanjalkar） 各位早上好！今天我想聊聊 Miniscript，这是 Pieter Wuille、Andrew Poelstra 和我的一项工作，也汇集了来自许多比特币人的想法。从 2019 年夏天以来，它一直在变化。但现在，它已经到了一个非常稳定的状态，可以分享出来、让更多人部署了。我的演讲题目是：“Miniscript：可组合、可分析、更智能的比特币脚本”。这是一个简单的背景介绍，如果你对哪一些内容有兴趣，欢迎在演讲结束后联系我，我们可以聊聊。
比特币 Script 当前的问题 为了介绍开发 Miniscript 的动机，我要先讲讲当前的比特币 Script 语言的问题。从非常抽象的层面来说，在中本聪设计比特币时，“不，我不要给某一个人支付，我要给这个人可以使用的一个基于脚本的程序支付” 的想法可谓石破天惊。
（译者注：“脚本（script）” 和 “Script” 两者时常混用，但仔细区分的话，前者指的是比特币 UTXO 的一个部分，用于为 UTXO 设置花费条件；而 Script 指的是一种特定的编写的脚本的方式 —— 直接使用实际需要执行的指令来编写脚本。）
今天的比特币 Script 给大家一个关于脚本的概念，脚本就是一些可以执行的指令（可以运行的程序），由网络中的所有参与者各自运行、检查某一笔交易是不是有效的。但从原理上说，其设计有一些问题。首先，它很难分析。我知道我们很多的比特币人都正确地宣传了其表达能力有限的事实，但就是这样有限的表达能力，我们也不知道如何分析脚本。除非我们部署像 Miniscript 这样的东西（这是一种更为通用、可组合的框架），不然比特币就还是给某个人支付而已。它很难用，而且几乎所有的工具都难用 —— 从 xpub 钱包到多签名。当我们说多签名的时候，我们还要跟一个复杂的词语联系起来，真遗憾。概念上来说，它其实不那么复杂。而且，在 Miniscript 中你拥有所有的定制化工具。比如你要使用 3-of-5 多签名，你想改变其中的某一些东西，那么你需要一个比特币专家来帮你分析你的改动。这是一个来自 BOLT 3（闪电网络 HTLC 规范之一）的例子。
OP_IF # 用于惩罚交易 &amp;lt;revocationpubkey&amp;gt; OP_ELSE `to_self_delay` # 自主决定的时间锁长度 OP_CHECKSEQUENCEVERIFY OP_DROP &amp;lt;local_delayedpubkey&amp;gt; OP_ENDIF OP_CHECKSIG 我们后面会讲解这个例子，这是一份原样复制的脚本，你很难看出来它想干什么。专家可以看懂这段脚本想干什么，但分辨起来并不容易。</description></item><item><title>Taproot on hardware wallets</title><link>https://btctranscripts.com/zh/advancing-bitcoin/2022/2022-03-03-stepan-snigirev-taproot-hardware-wallets/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/advancing-bitcoin/2022/2022-03-03-stepan-snigirev-taproot-hardware-wallets/</guid><description>开场（Jeff Gallas） 我非常高兴地宣布我们今天的第一位演讲者，来自 Specter 的 Stepan Snigirev，他是 Specter Solutions 的 CTO，有 3 年的开发比特币软件钱包（soft wallets）和硬件签名器（hard wallets）的经历。欢迎 Stepan。
概述（Stepan Snigirev） 我今天的演讲主题是 “在硬件签名器上支持 Taproot”。我们刚刚激活了 Taproot，非常棒，是在去年 11 月激活的。一些软件钱包已经开始集成了，而且甚至一些硬件签名器也开始集成了。现在大部分人用的都是单调的 “单密钥、单签名” 方案。我想讲讲我们可以用 Taproot 做什么。我觉得应该大家都知道了，所以我会讲快一点，然后我会讨论为什么在硬件签名器中集成 Taproot 是非常困难的、难点在哪里。如果我们无法在硬件钱包中集成，我们还有什么办法？
通过隐藏实现隐私 Taproot 非常出色。首先是它给了用户隐私性。在你观察区块链的时候，如果你看到一个单签名和单公钥的 taproot 地址，它里面可能实际上是一个公钥和一个脚本树。然后，这个公钥自身也可能凝结了一组公钥，而这棵脚本树可能非常高，是许许多多脚本的复杂集合。在里面你可以放置任意类型的时间锁，然后备份平时不会用到的私钥、仅在紧急情况下才启用它们。这意味着，所有复杂的花费条件，在链上看起来都是一样的。这是非常棒的事。甚至放在脚本中的公钥也可以代表着一组公钥，这就像是无限阶的密钥聚合。非常酷。
Miniscript（更安全的明文备份） 我个人会使用它的第一个理由是，它支持更好的明文备份。为什么现在没有人使用 Miniscript 或者复杂的比特币脚本？首先是因为比特币脚本复杂而不容易编写（在 Miniscript 出现之前）。其次是所有人都不使用它。这是一个鸡生蛋还是蛋生鸡的问题：每个人（90%）都使用单签名脚本，10% 的人使用多签名脚本，只有 0.3% 的人使用定制化的脚本。如果你使用一些定制化的脚本，你就暴露在了这 0.3% 里面。所有的链分析公司都知道，要是使用这样的脚本，那很有可能是同一个人。这样的隐私性非常糟，这就是障碍之一。
花费条件：or(HW, and(backup, timelock))
描述符：tr(HW, {and_v(v:pk(backup), older(timelock))})
Tapscript：&amp;lt;backup&amp;gt; OP_CHECKSIGVERIFY &amp;lt;timelock&amp;gt; OP_CHECKSEQUENCEVERIFY
（译者注：这段花费条件的意思是：一个硬件签名器随时可以花费这笔钱；同时，时间锁过期后，后备私钥也可以花费这笔钱。）
我个人会使用，我非常害怕把明文的钱包复原词（recovery phrases，应指种子词）放在我家里。如果有人得到了它，那我的钱就全部丢了。我个人的做法是使用一个不备份的硬件钱包，然后设置一个备用脚本，这个备用脚本带有时间锁，加上复原词就可以花费我的钱。然后，如果我遇到了什么意外，或者我的硬件钱包坏了，那么等待一段时间（也许半年）我就能拿回我的钱。但是，如果我的复原词被盗了，他们是没法立即偷走我的钱的（只要硬件钱包还在我手上的话）。我有足够多的时间，将资金迁移到一个新的装置上。但是，想想硬件签名器和 Miniscript 实现，现在还没有一个东西真正支持这个功能。太糟糕了。但实际上这并不是很难。在我给我们的硬件签名器集成 Miniscript 的时候，基本上我只花了一周的时间。我只要坐下来就可以开始开发了，因为它的说明真的写得非常好。Miniscript 有两个元素，其中一个你可以忽略，另一个是，如果你有一段可读的 policy 表达式，你就可以把它转成钱包的描述符。这有点复杂，但你不需要在硬件签名器里完成操作。第二部分是将钱包的描述符编译成实际的比特币脚本。这基本上只是把这些记号替换成比特币脚本的操作码，然后把派生出来的密钥放在正确的位置上。非常简单。然后硬件签名器就可以确定哪个输出是找零，并验证找零输出是从相同的描述符中派生出来的。这就行了。我想提一句，Ledger 团体最近做了很多工作来升级他们的比特币应用。他们在设计的时候就采用了 Miniscript 方法。虽然现在仅支持多签名功能，但很容易就能升级到支持定制化的 Miniscript，所以我很期待。至于硬件签名器，我不知道他们的计划。但至少会有两种硬件签名器将支持 Miniscript。</description></item><item><title>Transaction Relay Policy</title><link>https://btctranscripts.com/zh/adopting-bitcoin/2021/2021-11-16-gloria-zhao-transaction-relay-policy/</link><pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/adopting-bitcoin/2021/2021-11-16-gloria-zhao-transaction-relay-policy/</guid><description>主题：L2 开发者须知的交易转发规则
位置：Adopting Bitcoin
幻灯片：https://github.com/glozow/bitcoin-notes/blob/master/Tx%20Relay%20Policy%20for%20L2%20Devs%20-%20Adopting%20Bitcoin%202021.pdf&amp;gt;
引言 哈咯我是 Gloria，我在 Brink 公司为 Bitcoin Core 开发。今天我准备聊聊 “交易池规则（mempool policy）” 以及为什么你不能理所当然觉得你的交易会被广播、你的手续费追加方法要如何才能生效。我们正在做的事情就是要解决这些难题。如果你发现交易池有点难懂、不稳定、不可预期，你不确定自己的开发应用时能否放心使用交易池这个接口，这个演讲就是为你准备的。我猜大部分内容都对你有用。希望今天我们能让交易池变得更容易理解。
我的目标是让大家尽可能理解为交易的传播设置的各种限制。而我尝试的视角是作为一名比特币协议开发者的视角 —— 协议开发者如何思考交易池规则和交易转发策略。我接下来要定义什么是 “交易池规则”、我们如何分析它、问什么我们需要特定的策略并定义 “钉死攻击（pinning）”。我会从一些已知的限制开始，可能会清理一些关于攻击界面的误解。我还会提到一种对闪电通道的攻击。
我的目标是，在大家听完演讲之后，就能成为朋友，然后开始讨论如何在 Layer 1 和 Layer 2 之间开发通畅的桥梁。
任何人都能发送比特币支付 我想从头开始，确认我们对比特币的理解是一致的。我们想要比特币这样的系统，是为了让任何人都能把钱发给另一个人。这就是比特币的全部。
人们经常使用 “免准入（permissionless）” 和 “去中心化（decentralized）”、“免信任（trustless）” 这样的词来指称比特币。但可能一个更准确的框架是这样的。我们想要的第一个特性，是非常便宜就能运行一个节点。假如说 —— 我们举个例子哈 —— bitcoind 无法运行在 MacOS 上，或者它需要 32 GB 的内存、需要每月 2000 美元的代价才能运行一个全节点，那这对我们来说是不可接受的。我们希望它能运行在你的树莓派（Raspberry Pi）上，也就是很便宜的硬件就能运行。我们想要的另一个特性是 “抗审查性（censorship resistance）”，因为我们在尝试开发一个系统、帮助那些无法获得传统金融系统服务的人。如果我们开发出来的支付系统，很容易就能被某一些政府、富有的大银行、大公司任意审查他们不喜欢的交易，那我们就失败了。还有一种特性，显然，是安全性。在这个领域，我们不能依赖于某一些政府，由他们来确定 “这个节点在现实生活中就是这个人，他做了一些坏事，我们去起诉他”，我们没有这样的选择。我们希望每个人都能运行自己的节点，这是比特币的设计哲学中属于免信任性和去中心化的一部分。因此，安全也不是一个可选项，而是我们设计交易转发策略时候的首要考量。第四，我们不能强迫任何人运行比特币节点的一个新补丁，所以，当我们说某一个升级会优化用户的隐私性、但矿工的成本会变得更高、损失 50% 的收入或交易手续费会变得更高时，我们无法期待其他人会升级自己的节点。在讨论交易转发时，激励兼容也是一个始终需要考虑的东西。这就是我们思考这些事物的基本框架。
点对点的交易转发网络 希望这些对你来说并不意外，但是，要知道，在比特币中，我们需要在一个分布式的点对点网络中实现这些特性 —— 理想情况下，每个人都运行一个比特币节点、连接到比特币网络。这样的连接有许多形式：可能是你在自己的笔记本后台运行一个 bitcoind 程序、你安装了 Umbrel 或者 Raspiblitz 的树莓派小电脑，也可能是一个服务几千个智能手机钱包用户的大公司的服务器。所有这些都是一个比特币节点。它们本身非常不一样，但在点对点网络中，它们都是一个比特币节点。在你尝试给某人支付的时候，你要做的就是连接你的节点、提交你的交易、将交易广播给你的对等节点，希望这些对等节点会继续广播你的交易、最终将交易传播给某一个矿工。矿工会将交易打包到某个区块。
交易池 交易转发策略的真正关键的地方在于：每个参与交易转发的人都维护着一个交易池（mempool）。如果你想知道 “交易池” 的定义，我这里有一个：它是 “未确认的交易（unconfirmed transactions）” 的缓存（cache），并且是为了选出最为激励兼容（也即手续费率最高）的交易集合而专门优化的。这个优化方向不论对矿工还是非矿工都有意义，它帮助我们优雅地重组（re-org）、允许我们以更私密的方式设计交易转发策略，因为我们希望它比 “只懂 接受-转发” 更聪明一些。这是非常有用的，我在这个主题上写了许多东西。</description></item><item><title>Miniscript</title><link>https://btctranscripts.com/zh/tabconf/2021/2021-11-06-andrew-poelstra-miniscript/</link><pubDate>Sat, 06 Nov 2021 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2021/2021-11-06-andrew-poelstra-miniscript/</guid><description>主题：Miniscript：资金保管，可计算，可组合
场合：TABConf (The Atlanta Bitcoin Conference)
幻灯片：https://download.wpsoftware.net/bitcoin/wizardry/2021-11-tabconf/slides.pdf
引言 我准备讲讲 Miniscript。有些东西我之前就讲过，只不过讲述的方式更偏技术，侧重于讲解 Bitcoin Script 语言的困境、Miniscript 是什么、如何使用 Miniscript，等等。今天我准备从真正尝试使用比特币的人的角度谈谈 Miniscript，看看它是怎么解决这个行业中的一些我认为极为关键的问题的 —— 资金保管（custody）、密钥跟踪，等等。
在开始之前，我要先介绍一下本次演讲的结构。我准备花几页幻灯片稍微讲一讲比特币的脚本（bitcoin script）。比特币脚本是比特币内置的一个系统，用来定义资金的花费条件。一般来说，在普通的比特币钱包中，它使用的脚本的意思是 “为了移动这笔资金，交易需要提供某个公钥的签名”。这种脚本只是包在你的公钥上的薄薄的一层皮。但你还可以用脚本做出更有意思的东西。你可以指定，“这里有 3 个公钥，需要任意 2 个公钥的签名（才能花费这笔资金）”，比如说实现基于 2-of-3 多签名的保管方案。你还可以检查某个公钥在启用之前是否经过了特定的一段时间。你可以检查某个哈希值的原像是否被揭晓（这就是闪电网络的 HTLC 的工作原理）。所有这些巧妙的技术特性都可以在比特币脚本中实现。
但在现实中，有一些问题导致这些特性极难使用。结果就是当前的绝大部分比特币钱包完全不使用有趣的脚本。它们不单这么做，还做得彼此之间无法互通。
我想证明的正是，在 Bitcoin Script 以外，我们还有别的办法可以编写比特币的脚本；你可以使用这个被称为 “Miniscript” 的方法，获得一个易于分析的脚本编写框架。
资金保管是我持续关注的问题。你如何保管你的币？“可计算”，意味着有了 Miniscript，你可以分析你的脚本在做什么。你可以分辨出它的开销，因此可以作出准确的手续费估计。你可以确定你的脚本的语义特性。你还可以问这样的问题：“给定一些任意复杂的脚本，有人能不使用我的签名而使用这些脚本拿走我的资金吗？”对任何复杂的脚本我们都应该追问这个问题。在 Miniscript 之前，答案基本上就是：“我不知道。别用它。老实使用你知道的东西、老实沿用模板，老实使用大家分析过的东西。” 但有了 Miniscript ，你就可以编写任意复杂的脚本，同时依然能回答这个问题。第三个关键词是 “可组合”。这个很有趣，它本身是一个技术词汇，但它的前提非常直接。如果你有一个高级的花费方案（spending policy），但你想把其中的某一部分替换成一些复杂的东西，如果你只有 Bitcoin Script，你是无法轻易且可验证地做到的。但有了 Miniscript 你就可以做到。
一个例子是，你是一家公司的董事，这家公司持有大量比特币。你同意参与某种多签名方案，5 名董事中需要 4 位的签名才能移动资金。你是成员之一。现在其他人要求你提供一个公钥。但你不想给它们 一把 公钥，因为你可能会弄丢对应的私钥。你不把自己的比特币放在只有一个公钥控制的输出中也是同样的理由。你想要一些冗余，一些弹性。所以，理想情况下，你应该能表示 “在这个 4-of-5 方案中，我的部分将是一个 2-of-3 方案。我把这三个公钥放在了不同的地点，按不同的方式保护了起来。” 使用 Bitcoin Script 你是做不到的。如果某人向你请求一个公钥，而你回复以这样复杂的公钥组合和规则，收到信息的人以及参与同一个脚本的其他人都需要艰难地验证你这部分没有错。基本上，你做的事情就是提供一段脚本（一段计算机代码）、要求把这段代码插入到另一段计算机程序中，而这段程序的模式并不符合人们思考花费方案的方式。
Bitcoin Script 的问题 我这里有几张幻灯片列举了 Script 的问题。有一些是非常技术性的，只有钱包开发者才会在意。有一些则是每个人等应该关注的，尤其是前两个。</description></item><item><title>Covenants</title><link>https://btctranscripts.com/zh/tabconf/2021/2021-11-05-jeremy-rubin-andrew-poelstra-covenants/</link><pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/tabconf/2021/2021-11-05-jeremy-rubin-andrew-poelstra-covenants/</guid><description>主题：Covenants
场合：TABConf (The Atlanta Bitcoin Conference)
视频：互联网上无视频放出。
根据 “苏格拉底村” 规则，（除了演讲者之外）所有与会者都使用了假名；音频也不会公开，以保护提问者的匿名。
限制条款的概念 Shaun Apps（SA）：我先做个开场吧。Andrew 和 Jeremy 都会来。然后我们就以问答的形式开展，最后再回答观众的提问。这就是本场演讲的形式。
SA：言归正传，限制条款（covenant）。这个术语有宗教和法律方面的历史语境。大多数人理解的可能是物权法范畴内的概念，比如使用限制条款来约束土地的用途。但是，你们有多少人知道它在比特币领域内的意思？好的，看来很多人都听过。所以，基本上，限制条款给予了比特币脚本内省的能力，例如你可以通过预先定义的约束来限制一个输出的花费方式。我不太清楚限制条款的概念可以追溯到多久远以前。但是这一篇影响力很大的 BitcoinTalk 论坛帖子，作者是 Greg Maxwell，就介绍了限制条款的概念，并提出了一些假想的案例。举个例子，一种 Smashcoin 限制条款，在花费由此种条款锁定的资金时，必须提供攻击另一种密码货币的证据；甚至是一种 adultcoin 限制条款，必须提供某人的生日才能花费，它会限制接收者的年龄必须大于 18 岁。当然，这些都只是假设的、博君一笑的例子，这篇帖子也只是一个玩笑。但是，今天我们能够看到，限制条款有一些非常激动人心的用途。有请 Andrew Poelstra 和 Jeremy Rubin。Andrew 准备从 CHECKSIGFROMSTACK（也叫 “CSFS”）的视角出发，理解限制条款。Jeremy 的演讲则讨论 CHECKTEMPLATEVERIFY（也叫 “CTV”）。其实，有不止一种办法可以在比特币中实现限制条款。不同的想法、不同的提议，都有自己的取舍也应用场景。所以，我们来好好探究一番。Andrew，你想先来吗？
Andrew Poelstra（AP）：当然。如 Shaun 所说，某种程度上我代表着限制条款的 CHECKSIGFROMSTACK 流派。这种流派似乎代表着一种更普遍的视角。所以，为了帮助大家建立限制条款的概念 —— 我认为，这个概念确实肇始于那个 BitcoinTalk 帖子 …… 我不知道有什么讨论比这个更早 ……
Jeremy Rubin（JR）：那也是我所知最早的。
递归和非递归的限制条款 AP：有两种类型的限制条款，我把它们叫做 “递归型限制条款” 和 “非递归型限制条款”。我想这两个术语可能也源自那篇文章。“限制条款” 是且只是一种限制资金可以花到哪里去的办法。使用比特币脚本，你可以决定在什么条件下一笔资金可以移动，然而，一旦条件满足，资金就可以去任何地方。而限制条款则更进一步，允许你限制它的去向，实现上面说的种种傻事。
非递归的限制条款和递归的限制条款有一个区别。在非递归的限制条款中，你可以限制一笔资金的去向。你可以把它引到另一个限制条款中，从而进一步约束其去向，等等。但是，你必须规划出这笔资金的全部未来，你可以让它经历很多个限制条款，但你必须在一开始就把所有的限制条款写出来。递归型限制条款则不同，你可以让资金回到一个本质上与其来源相同的限制条款中；这就创造了一种有限的状态机，资金可以在不同的状态中移动。要么资金可以只待在一个地方，只是改变一些常数；要么它们可以移动到不同的状态，甚至它们可以返回原来的状态。凭借它，你可以创建一种让资金无法逃离的限制条款。甚至我的用词，“无法逃离”，也反映出其内在的危险性，同时也反映了许多年来人们对启用递归限制条款的恐惧。
不同的限制条款提议 AP：这些年出现了许多的限制条款提议。其中一个是 Jeremy Rubin 的 OP_CTV，曾用名 “OP_SECURETHEBAG”。在它的整个生命中，它有过多个名称，也经历了几次迭代。OP_CTV 被有意设计成规避递归型限制条款，以避免所有这些看似是玩笑、某个层面上又不是玩笑的东西。不过，另一种非常著名的限制条款提议，是非常通用的，它基于两种新的操作码，CHECKSIGFROMSTACK 和 CAT。 还有一种更为高效的变种，它增设的操作码可以直接检查正在花费这笔资金的交易。也就是说你可以直接把花费资金的交易本身拉取到堆栈中，然后执行你的脚本、直接地约束它们。一定程度上，你是在直接检查花费资金的交易、为之施加任意的约束。尤其是，如果你限制了交易的输出，那你就实现了一种递归型限制条款，可以永久困住这笔资金。这两种方法之间存在取舍。如果你尝试做一些事情来避免递归型限制条款 ……</description></item><item><title>A Scalable Drop in Replacement for Merkle Trees</title><link>https://btctranscripts.com/zh/scalingbitcoin/tokyo-2018/accumulators/</link><pubDate>Sat, 06 Oct 2018 00:00:00 +0000</pubDate><guid>https://btctranscripts.com/zh/scalingbitcoin/tokyo-2018/accumulators/</guid><description>一种马上可用且可扩展的默克尔树替代品
https://twitter.com/kanzure/status/1048454406755168257
开场白 哈咯。声音测试。没问题。
我今天准备讲讲 UTXO 的累加器（accumulators）。前面的两场演讲给本演讲做了很好的铺垫。本演讲涉及的工作是我和 Ben Fisch（他今天也在这里）和 Dan Boneh 的联合成果。我还希望给 Stanford Blockchain Conference（曾用名 BPASE）打个广告，这个会将在 2019 年 1 月在斯坦福召开。无论你是否要去演讲，你都应该去看看。
UTXO UTXO 集的膨胀是一个日益严重的问题。今天上午我们已经听过了关于 UTXO 集合中的粉尘（译者注：指面额过于微小，因此无法单独花费的 UTXO）。我们已经有大约 6000 万个 UTXO。这里面的问题，我们在前几场演讲中已经听过了：区块链在存储 UTXO 上是非常低效的结构，如果我要下载一个旧区块，那么我需要知道当前区块与该旧区块之间的所有区块头。如果我想下载一笔旧交易并检查这笔交易是否已经花掉了，并且我只知道最新的区块，那么我需要检查从该交易到最新交易之间的所有交易，看看有没有哪一笔花费了它。
UTXO 承诺 有人提议用 UTXO 承诺来解决这个问题。就像我们刚刚听过的，每个区块都包含一个对最新状态（例如当前的 UTXO 集状态）的承诺。这里的想法是，利用共识规则来保证区块头中包含一个事实上正确的 UTXO 承诺。轻客户端将能够检查这个承诺。如果我想说服一个轻客户端某个 UTXO 是存在的，那么我需要给 TA 一个证据，证明它在最新的 UTXO 集承诺所涵盖的数据中。我们可以使用这种思路，将所有人都变成一个轻客户端。
默克尔树 实现这种思路的经典办法是 “默克尔树”。默克尔树的建构方法就像这样。我可以给你一个包含证据，证明 UTXO 集中含有某些东西；在生成包含证据时，需要 log(n) 次哈希计算，而且我可以在某些时候更新证据，每次更新都是 log(n)。
无状态的全节点 这样一来，我就能建构一种无状态的全节点，它不需要存储完整的 UTXO 集。这是怎么工作的呢？当我要发送一笔交易的时候，我必须提供一个证据，证明我的交易在花费一个还没有被花过的币。在当前，矿工用自己的 UTXO 集检查我的交易。但在这种设计中，由用户自己证明自己的币还没被花费过。因此，矿工将不必存储 UTXO 集，就能直接检查一笔交易是否被花费过。这很有趣。
默克尔树的问题 但这种方法有一些问题。主要的问题是，如果每一笔交易都要附加这些包含证据，它们的体积会变得非常大。每一笔交易都需要包含证据，那么区块链会需要额外的 160 GB 空间。并且，在验证区块链时，你需要做许多昂贵的检查。在 Peter Todd 提到这一点时，他提议仅对非常老旧的交易使用这种方法，而大部分交易不应该被逼迫使用这种技术。</description></item></channel></rss>