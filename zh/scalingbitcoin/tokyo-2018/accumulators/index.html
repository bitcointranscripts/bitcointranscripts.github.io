<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=canonical href=https://btctranscripts.com/zh/scalingbitcoin/tokyo-2018/accumulators/><title>Accumulators | ₿itcoin 记录稿</title><link href=https://btctranscripts.com/css/fontawesome.min.css rel=stylesheet><link rel=stylesheet href=https://btctranscripts.com/css/ace.min.css><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://btctranscripts.com/images/btctranscripts.png"><meta name=twitter:title content="Benedikt Bünz, Benjamin Fisch, Dan Boneh - Accumulators"><meta name=twitter:description content="一种马上可用且可扩展的默克尔树替代品
https://twitter.com/kanzure/status/1048454406755168257
开场白 哈咯。声音测试。没问题。
我今天准备讲讲 UTXO 的累加器（accumulators）。前面的两场演讲给本演讲做了很好的铺垫。本演讲涉及的工作是我和 Ben Fisch（他今天也在这里）和 Dan Boneh 的联合成果。我还希望给 Stanford Blockchain Conference（曾用名 BPASE）打个广告，这个会将在 2019 年 1 月在斯坦福召开。无论你是否要去演讲，你都应该去看看。
UTXO UTXO 集的膨胀是一个日益严重的问题。今天上午我们已经听过了关于 UTXO 集合中的粉尘（译者注：指面额过于微小，因此无法单独花费的 UTXO）。我们已经有大约 6000 万个 UTXO。这里面的问题，我们在前几场演讲中已经听过了：区块链在存储 UTXO 上是非常低效的结构，如果我要下载一个旧区块，那么我需要知道当前区块与该旧区块之间的所有区块头。如果我想下载一笔旧交易并检查这笔交易是否已经花掉了，并且我只知道最新的区块，那么我需要检查从该交易到最新交易之间的所有交易，看看有没有哪一笔花费了它。
UTXO 承诺 有人提议用 UTXO 承诺来解决这个问题。就像我们刚刚听过的，每个区块都包含一个对最新状态（例如当前的 UTXO 集状态）的承诺。这里的想法是，利用共识规则来保证区块头中包含一个事实上正确的 UTXO 承诺。轻客户端将能够检查这个承诺。如果我想说服一个轻客户端某个 UTXO 是存在的，那么我需要给 TA 一个证据，证明它在最新的 UTXO 集承诺所涵盖的数据中。我们可以使用这种思路，将所有人都变成一个轻客户端。
默克尔树 实现这种思路的经典办法是 “默克尔树”。默克尔树的建构方法就像这样。我可以给你一个包含证据，证明 UTXO 集中含有某些东西；在生成包含证据时，需要 log(n) 次哈希计算，而且我可以在某些时候更新证据，每次更新都是 log(n)。
无状态的全节点 这样一来，我就能建构一种无状态的全节点，它不需要存储完整的 UTXO 集。这是怎么工作的呢？当我要发送一笔交易的时候，我必须提供一个证据，证明我的交易在花费一个还没有被花过的币。在当前，矿工用自己的 UTXO 集检查我的交易。但在这种设计中，由用户自己证明自己的币还没被花费过。因此，矿工将不必存储 UTXO 集，就能直接检查一笔交易是否被花费过。这很有趣。
默克尔树的问题 但这种方法有一些问题。主要的问题是，如果每一笔交易都要附加这些包含证据，它们的体积会变得非常大。每一笔交易都需要包含证据，那么区块链会需要额外的 160 GB 空间。并且，在验证区块链时，你需要做许多昂贵的检查。在 Peter Todd 提到这一点时，他提议仅对非常老旧的交易使用这种方法，而大部分交易不应该被逼迫使用这种技术。"></head><body><nav class="navbar navbar-expand-lg navbar-dark bg-primary shadow sticky-top" id=navbarMain><div class=container><div><a class=navbar-brand href=/zh>₿itcoin 记录稿</a></div><div class="collapse navbar-collapse" id=navbarMainCollapse><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/en>en</a></li><li class=nav-item><a class=nav-link href=/es>es</a></li><li class=nav-item><a class=nav-link href=/pt>pt</a></li><li class=nav-item><a class=nav-link href=https://github.com/bitcointranscripts/bitcointranscripts target=_blank><i class='fab fa-github'></i></a></li></ul></div></div></nav><div class=container-fluid><div class=row><div class="docs-sidenav order-0 col-12 col-md-3 col-lg-2 col-xl-2 position-sticky border-right"><nav class="navbar navbar-expand-md navbar-light pl-0"><button class="navbar-toggler navbar-toggler-right collapsed" type=button data-toggle=collapse data-target=#sidenav-left-collapse aria-controls=sidenav-left-collapse aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse align-items-start flex-column" id=sidenav-left-collapse><form class="form-inline my-2 my-lg-0 searchbox"><input class="form-control mr-sm-2 w-100" data-search-input id=search-by type=text placeholder='Search (press "/")'></form><ul class="navbar-nav flex-column pt-3"><li data-nav-id=/zh/advancing-bitcoin/ class="nav-item my-1 haschildren"><a class="nav-link p-0" href=/zh/advancing-bitcoin/><h6>Advancing Bitcoin</h6></a><ul class="list-unstyled ml-2"><li data-nav-id=/zh/advancing-bitcoin/2022/ class="nav-item my-1 haschildren"><a class="nav-link p-0" href=/zh/advancing-bitcoin/2022/><h6>Advancing Bitcoin 2022</h6></a><ul class="list-unstyled ml-2"></ul></li></ul></li><li data-nav-id=/zh/scalingbitcoin/ class="nav-item my-1 parent haschildren"><a class="nav-link p-0" href=/zh/scalingbitcoin/><h6>Scaling Bitcoin Conference</h6></a><ul class="list-unstyled ml-2"><li data-nav-id=/zh/scalingbitcoin/tokyo-2018/ class="nav-item my-1 parent haschildren"><a class="nav-link p-0" href=/zh/scalingbitcoin/tokyo-2018/><h6>Tokyo (2018)</h6></a><ul class="list-unstyled ml-2"></ul></li></ul></li><li data-nav-id=/zh/tabconf/ class="nav-item my-1 haschildren"><a class="nav-link p-0" href=/zh/tabconf/><h6>TABConf</h6></a><ul class="list-unstyled ml-2"><li data-nav-id=/zh/tabconf/2021/ class="nav-item my-1 haschildren"><a class="nav-link p-0" href=/zh/tabconf/2021/><h6>TABConf 2021</h6></a><ul class="list-unstyled ml-2"></ul></li><li data-nav-id=/zh/tabconf/2022/ class="nav-item my-1 haschildren"><a class="nav-link p-0" href=/zh/tabconf/2022/><h6>TABConf 2022</h6></a><ul class="list-unstyled ml-2"></ul></li></ul></li></ul></div></nav></div><div class="docs-toc large order-lg-2 order-md-0 order-xs-1 col-12 col-lg-2 col-xl-2 position-sticky"><div class=docs-toc><nav id=TableOfContents><ul><li><ul><li><a href=#开场白>开场白</a></li><li><a href=#utxo>UTXO</a></li><li><a href=#utxo-承诺>UTXO 承诺</a></li><li><a href=#默克尔树>默克尔树</a></li><li><a href=#无状态的全节点>无状态的全节点</a></li><li><a href=#默克尔树的问题>默克尔树的问题</a></li><li><a href=#rsa-累加器>RSA 累加器</a></li><li><a href=#累加器证据>累加器证据</a></li><li><a href=#rsa-需要受信任的启动设置吗>RSA 需要受信任的启动设置吗？</a></li><li><a href=#类群>类群</a></li><li><a href=#rsa-累加器前沿>RSA 累加器前沿</a></li><li><a href=#聚合包含证据>聚合包含证据</a></li><li><a href=#无状态的删除>无状态的删除</a></li><li><a href=#太慢了>太慢了？</a></li><li><a href=#wesolowski-证据wesolowski-2018>Wesolowski 证据（Wesolowski 2018）</a></li><li><a href=#快速区块验证>快速区块验证</a></li><li><a href=#性能>性能</a></li><li><a href=#向量承诺>向量承诺</a></li><li><a href=#简短的-iop>简短的 IOP</a></li><li><a href=#qa>Q&amp;A</a></li></ul></li></ul></nav></div></div><div class="main col-12 order-1 col-md-9 col-lg-10 col-xl-8 py-3"><a href=/>Home</a>
&lt; <a href=/zh/tabconf/>TABConf</a>
&lt; <a href=/zh/advancing-bitcoin/>Advancing Bitcoin</a>
&lt; <a href=/zh/scalingbitcoin/>Scaling Bitcoin Conference</a>
&lt; <a href=/zh/scalingbitcoin/tokyo-2018/>Tokyo (2018)</a>
&lt; Accumulators<h1>Accumulators</h1><p>演讲者:
<a href=/zh/speakers/benedikt-b%C3%BCnz>Benedikt Bünz</a>, <a href=/zh/speakers/benjamin-fisch>Benjamin Fisch</a>, <a href=/zh/speakers/dan-boneh>Dan Boneh</a></p><p><i>记录者: Bryan Bishop</i></p><p><i>译者: Ajian</i></p><p>标签:
<a href=/zh/tags/merkle-trees>Merkle trees</a>, <a href=/zh/tags/accumulators>Accumulators</a></p><p>类别:
<a href=/zh/categories/conference>Conference</a></p><p>一种马上可用且可扩展的默克尔树替代品</p><p><a href=https://twitter.com/kanzure/status/1048454406755168257>https://twitter.com/kanzure/status/1048454406755168257</a></p><h2 id=开场白>开场白</h2><p>哈咯。声音测试。没问题。</p><p>我今天准备讲讲 UTXO 的累加器（accumulators）。前面的两场演讲给本演讲做了很好的铺垫。本演讲涉及的工作是我和 Ben Fisch（他今天也在这里）和 Dan Boneh 的联合成果。我还希望给 Stanford Blockchain Conference（曾用名 BPASE）打个广告，这个会将在 2019 年 1 月在斯坦福召开。无论你是否要去演讲，你都应该去看看。</p><h2 id=utxo>UTXO</h2><p>UTXO 集的膨胀是一个日益严重的问题。今天上午我们已经听过了关于 UTXO 集合中的粉尘（译者注：指面额过于微小，因此无法单独花费的 UTXO）。我们已经有大约 6000 万个 UTXO。这里面的问题，我们在前几场演讲中已经听过了：区块链在存储 UTXO 上是非常低效的结构，如果我要下载一个旧区块，那么我需要知道当前区块与该旧区块之间的所有区块头。如果我想下载一笔旧交易并检查这笔交易是否已经花掉了，并且我只知道最新的区块，那么我需要检查从该交易到最新交易之间的所有交易，看看有没有哪一笔花费了它。</p><h2 id=utxo-承诺>UTXO 承诺</h2><p>有人提议用 UTXO 承诺来解决这个问题。就像我们刚刚听过的，每个区块都包含一个对最新状态（例如当前的 UTXO 集状态）的承诺。这里的想法是，利用共识规则来保证区块头中包含一个事实上正确的 UTXO 承诺。轻客户端将能够检查这个承诺。如果我想说服一个轻客户端某个 UTXO 是存在的，那么我需要给 TA 一个证据，证明它在最新的 UTXO 集承诺所涵盖的数据中。我们可以使用这种思路，将所有人都变成一个轻客户端。</p><h2 id=默克尔树>默克尔树</h2><p>实现这种思路的经典办法是 “默克尔树”。默克尔树的建构方法就像这样。我可以给你一个包含证据，证明 UTXO 集中含有某些东西；在生成包含证据时，需要 <code>log(n)</code> 次哈希计算，而且我可以在某些时候更新证据，每次更新都是 <code>log(n)</code>。</p><h2 id=无状态的全节点>无状态的全节点</h2><p>这样一来，我就能建构一种无状态的全节点，它不需要存储完整的 UTXO 集。这是怎么工作的呢？当我要发送一笔交易的时候，我必须提供一个证据，证明我的交易在花费一个还没有被花过的币。在当前，矿工用自己的 UTXO 集检查我的交易。但在这种设计中，由用户自己证明自己的币还没被花费过。因此，矿工将不必存储 UTXO 集，就能直接检查一笔交易是否被花费过。这很有趣。</p><h2 id=默克尔树的问题>默克尔树的问题</h2><p>但这种方法有一些问题。主要的问题是，如果每一笔交易都要附加这些包含证据，它们的体积会变得非常大。每一笔交易都需要包含证据，那么区块链会需要额外的 160 GB 空间。并且，在验证区块链时，你需要做许多昂贵的检查。在 Peter Todd 提到这一点时，他提议仅对非常老旧的交易使用这种方法，而大部分交易不应该被逼迫使用这种技术。</p><h2 id=rsa-累加器>RSA 累加器</h2><p>那么，我想讲讲 RSA 累加器，它是默克尔树的一种替代。我们需要选择一个 RSA 模量，它是一个很大的数（N），是两个大质数（p，q）的乘积。我们还需要一种哈希函数，将任意元素映射成质数。然后，我们从群（the group）（Z<sub>N</sub>，译者注）中选出一个元素（下文称为 “g”，译者注）来初始化一个累加器（即定义累加器的初始值 $A_0 = g$ ，译者注）。</p><p>这种累加器要怎么用呢？假设我们要在集合中加入一些东西。这种累加器是对某个集合的一个简短的的承诺。如果我们想要给一个累加器加入一些东西，我们就以被加入的元素为幂次，求累加器原值的幂，即 Add(A<sub>i</sub>, x)=A<sub>i</sub><sup>H(x)</sup>。要是我们需要删去一些东西，我们就以被删元素的倒数为幂次，求累加器原值的幂，即 Del(A<sub>i</sub>, x)=A<sub>i</sub><sup>1/+H(x)</sup>。这里实际上都需要把元素哈希成质数，但在演讲剩下的时间里我会假设每一个元素都是一个质数。这是可以做到的。</p><p>如果我要表示一个 UTXO 集 S，那么相应的累加器的值就是 g 的幂，次数为 S 中所有元素的乘积。这种累计器的一个很好的属性是，不必管元素添加的顺序，这种次序是完全可交换的。它还有其它很好的特性。</p><h2 id=累加器证据>累加器证据</h2><p>这种累加器的包含证据是非常简单的，只需要求累加器的现值（A）的被证明元素（x）的倒数次幂（A<sup>1/x</sup>）。这可以通过使用一个陷门（trapdoor），或者说构建累加器的秘密值（p，q），来计算；我们可以优化这一点。不然，你就得知道整个集合，才能计算出来。如果累加器是诚实地构造的，那么这样的计算会给累加器的现值消去一定的幂次，从而依然得到一个有效的累加器值。在 RSA 群有安全证明，如果 x 不在集合中，你是没办法做这样的操作的。</p><p>我们也可以创造出非包含证据，相对要复杂一些，所以我在这里就跳过这些细节了，你可以直接看大屏幕（译者注：Exclusion(A, x): A = g<sup>u</sup> ; a · x + b · u = gcd(x, u)=1​）。它使用了 bazooko 系数。详见 LiLiXue07。你可以作非常高效的无状态更新。我可以高效地告诉你：无论哪一笔交易或者什么东西加入集合或者从集合中移除，我都可以相应地更新我的证据。在我们的论文中，我们说明了可用的方法。</p><h2 id=rsa-需要受信任的启动设置吗>RSA 需要受信任的启动设置吗？</h2><p>你可能已经听过了这些东西，并且认为，这是没用的，因为 RSA 累加器需要一次受信任的启动设置。要由谁来执行这个受信任的启动设置？“受信任的启动设置” 又是什么意思呢？</p><p>问题就在于 N 是 p 和 q 的乘积；如果某人知道 p 和 q，那 TA 就可以完全攻破整个方案，并欺骗你，让你以为某个元素在某个累加器中（即使这并非事实）。而且，累加器的高效删除需要一个陷门。传统的方案假设了有一个累加器管理员，来做这些事。另外，你有可能可以直接找出 N（Ron Rivest 假设）。</p><p>的确有一些时候，可以产生没有人知道陷门的 N，例如，Ron Rivest 一开始创建了一个 RSA 难题，并且他删除了 p 和 q，如果你信任他（他可是那么著名的密码学家，还是图灵奖得主呢），那么你就可以使用他给出的 N 值。又或者，有一家很老的公司，他们现在破产了，他们在一个硬件模块中保存了一个私钥，而这个模块在这家公司破产的时候毁坏了。也许这样的 N，你也是可以合理使用的。但这可能还不够好。</p><h2 id=类群>类群</h2><p>BW88 和 L12 两篇论文提议使用 “类群（Class groups）”。类群是一个令人惊讶的数学概念，最初由高斯（Gauss）提出 …… 这是一个二次方根数领域的类群（it’s a class group of quadratic number fields），这其中的想法是，这是一个不明阶数的群，所以你不知道这个群中有多少个数。它的属性类似于 RSA，但并不要求受信任的启动设置。类群的元素比 RSA 元素稍微短一点，大概是其长度的一半。</p><h2 id=rsa-累加器前沿>RSA 累加器前沿</h2><p>如果只考虑包含证明，RSA 累加器的证据是固定大小的，无论累加器覆盖了多少数据。证据将一直是 3000 比特。当集合的体积大于 4000 个元素时，RSA 包含证据比默克尔包含证据要好。而且，它还有 “动态无状态添加” 特性，就是你可以给累加器增加元素，而无需知晓整个集合。你可以把这个用在去中心化存储中；一个完全验证的节点不需要存储，用户会维护自己的 UTXO 和相应的包含证明。</p><p>这里的提升空间在于聚合以及批处理包含证明：要是我有许多个证据，我怎么聚合它们呢？另外，我们能实现无状态删除吗，也就是在不知道整个集合时，为累加器删除元素？验证速度还能更快吗？</p><h2 id=聚合包含证据>聚合包含证据</h2><p>假设我们有同一个累加器的两个包含证据。事实证明，我们可以利用叫做 “Shamir 技巧” 的方法，创建别的东西 —— 你想要检查的这两个元素的一个包含证据。只要我们能对两个元素实现，那么我们就能对任意数量的元素实现。把一个区块中的所有包含证据都合并成一个 —— 而不是让每一笔交易都附带一个默克尔证据或者一个 RSA 包含证据。所以，我们不需要前面说的额外的 160 GB 的存储空间，只需要 1.5 kB，你甚至可以打印在一张纸上。</p><h2 id=无状态的删除>无状态的删除</h2><p>如果我有一个陷门，我就能做到高效删除。但要是我们没有呢？我们改变一下模型：我们假设每次我们想要删除某些元素的时候，我们实际上都有一个可用的包含证据。什么时候我们需要从 UTXO 集中删除东西？无非是某一个 UTXO 被花费的时候。但在它被花费的时候，用户总要提供相应的包含证据。那么，累加器的下一个值将正好等于这个证据；为什么这么说呢？因为这个证据就是 <code>g^(u/x)</code> ，相等于把 x 从集合中消去了。也即，证据恰好就是累加器现值删去被证明的元素后得到的值。因此我们可以把累加器的值设为这个证据的值。在区块链中，情形稍有区别，因为我们会有许多笔交易，因此有许多个对应于同一个累加器值的包含证据。这里，我们又可以利用前面提到的同一种技巧 —— 把所有包含证据合并成一个包含证据，然后更新我们的累加器。这就是我们实现无状态删除的办法，所以我们可以实现批量删除功能。即使我们只有对同一个累加器值的多个证据，也能一次性删除它们。</p><h2 id=太慢了>太慢了？</h2><p>RSA 有点慢，它比哈希计算要慢。如果你的设置是一个 2000 比特的 RSA，那么每秒只能做 219 次更新。这有点慢，尤其是对完全同步（full sync）来说，你需要更新整个区块链，因此需要检查所有这些证据，同步会变得非常慢。聚合技术只能降低证据的体积，不能节约验证时间。</p><p>对于类群，现在还没用基准测试，但它已经用在 “可验证延迟函数（verifiable delay functions）” 中了。Chia 项目刚刚推出了一个比赛，你可以尝试加速类群的计算或尝试打破它们，我记得奖金好像是 10 万美元。我们很快会更清楚这些东西实际上有没有用、安不安全。</p><h2 id=wesolowski-证据wesolowski-2018>Wesolowski 证据（Wesolowski 2018）</h2><p>我们可以用 Wesolowski 证据来减低验证时间，这是在可验证延迟函数的开发者产生的技术。你也可以使用幂计算证据（proof of exponentiation）。使用 128 比特的大数除法（也即幂计算证据的验证），相比于直接验证，是显著的加速（大约快上 5000 倍）。</p><h2 id=快速区块验证>快速区块验证</h2><p>现在我们也可以实现快速的区块验证。假设我是一个矿工，我希望组装我的区块。基于区块链的最新状态，累加器的最新状态，我可以使用无状态删除技术，从累加器中移除一批元素 …… 也就是移除所有被花费的 UTXO …… 然后给累加器加入新的假以，然后我组装新的区块，它依然有区块头，以及相应的交易，可能还有一个 BLS 签名（这是 一种小体积的签名）。然后，它还有两个值，一个是上一个累加器值移除所有被花费的 UTXO（集合为 “s”）之后得到的值（称为 “半路值”），另一个是半路值加上所有新产生的 UTXO （集合为 “n”）之后得到的值（称为 “完全值”），以及它们的幂计算证据。</p><p>那么，完全验证节点现在需要做什么呢？TA 必须验证 BLS 签名（这可以很快），然后验证两个幂计算证据（在现实中也非常快）。你只需要检查，从上一个累加器值删去 s 是否可以得到半路值，从半路值加上 n 是否可以得到新的累加器值（完全值），即可。</p><h2 id=性能>性能</h2><p>那么这一套技术的表现如何？请谨慎看待我提供的数字。</p><p>我在我的 macbook 笔记本电脑上使用标准的 java 库做了测试。使用默克尔数，对 6400 万个元素的集合生成一个包含证据需要大概 20 次哈希计算，是 8.5 微秒。要是我使用新的 Wesolowski 证据，验证它只需要 0.3 微秒，这比默克尔树快很多。至于类群，我们不知道。会更快还是更慢？类群的体积更小，但也说不准更快还是更慢。在 Pieter Wuille 实现之前，我们很难估计。</p><h2 id=向量承诺>向量承诺</h2><p>“向量承诺” 类似于累加器。你也可以使用默克尔树来实现。这是一种对某一个向量的承诺，所以我可以在某个位置开启它，然后告诉你这个向量在位置 x 有一个值。我们开发了一种新的向量承诺，之前也有来自 RSA 的向量承诺，但验证将需要几 GB 的内存，或者内存会线性增长，而我们的方案不需要内存，所以更加高效。</p><h2 id=简短的-iop>简短的 IOP</h2><p>像 STARK 这样的零知识证明技术 …… 或者说叫做 “IOP” 的零知识证明技术类，大体上，是证明者为更长的证据创造一个更短的承诺，然后验证者请求一些索引，证明者发送相应的证据以及默克尔证据，证明在位置 x，证据就是这个数值，然后验证者可以接受或拒绝。问题在于，默克尔路径本身非常大，我们可以用向量承诺来替代，然后我们可以聚合向量承诺，将它缩减到几 kB，而不是大量的默克尔证据。可以将证据体积缩减到 …… 这些数字都来自于一种设定，很难获得真实的数字，因为你要看设定是什么样的。对于一个比较大的设定，你可以将证据的体积从几百缩减到几十。这会渐渐逼近以 <code>log(n)</code> 的缩减比率 。所以证据可以变短。</p><h2 id=qa>Q&amp;A</h2><p>（无）</p><h4></h4><ul><li><a href=/scalingbitcoin/tokyo-2018/accumulators/>en: Accumulators</a></li></ul><div class=row></div></div></div></div><script src=https://btctranscripts.com/lib/jquery.min.js></script>
<script src=https://btctranscripts.com/lib/popper.min.js></script>
<script src=https://btctranscripts.com/js/bootstrap.min.js></script>
<script type=text/javascript src=/plugins/lunr.min.js></script>
<script type=text/javascript src=/plugins/auto-complete.js></script>
<link href=/plugins/auto-complete.css rel=stylesheet><script type=text/javascript>var baseurl="https://btctranscripts.com//zh"</script><script type=text/javascript src=/plugins/search.js></script>
<script type=text/javascript src=https://btctranscripts.com/js/custom.js></script>
<script type=text/javascript src=/plugins/clipboard.js></script>
<script>new ClipboardJS(".btn")</script></body></html>